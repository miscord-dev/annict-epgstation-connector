// Package epgstation provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package epgstation

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

// Defines values for ChannelType.
const (
	BS  ChannelType = "BS"
	CS  ChannelType = "CS"
	GR  ChannelType = "GR"
	SKY ChannelType = "SKY"
)

// Defines values for ProgramAudioSamplingRate.
const (
	N16000 ProgramAudioSamplingRate = 16000
	N22050 ProgramAudioSamplingRate = 22050
	N24000 ProgramAudioSamplingRate = 24000
	N32000 ProgramAudioSamplingRate = 32000
	N44100 ProgramAudioSamplingRate = 44100
	N48000 ProgramAudioSamplingRate = 48000
)

// Defines values for ProgramVideoResolution.
const (
	N1080i ProgramVideoResolution = "1080i"
	N1080p ProgramVideoResolution = "1080p"
	N2160p ProgramVideoResolution = "2160p"
	N240p  ProgramVideoResolution = "240p"
	N4320p ProgramVideoResolution = "4320p"
	N480i  ProgramVideoResolution = "480i"
	N480p  ProgramVideoResolution = "480p"
	N720p  ProgramVideoResolution = "720p"
)

// Defines values for ProgramVideoType.
const (
	H264  ProgramVideoType = "h.264"
	H265  ProgramVideoType = "h.265"
	Mpeg2 ProgramVideoType = "mpeg2"
)

// Defines values for StreamType.
const (
	LiveHLS        StreamType = "LiveHLS"
	LiveStream     StreamType = "LiveStream"
	RecordedHLS    StreamType = "RecordedHLS"
	RecordedStream StreamType = "RecordedStream"
)

// Defines values for VideoFileType.
const (
	Encoded VideoFileType = "encoded"
	Ts      VideoFileType = "ts"
)

// AddManualEncodeProgramOption エンコード手動追加時のオプション
type AddManualEncodeProgramOption struct {
	// Directory 親ディレクトリ以下のディレクトリ設定
	Directory *string `json:"directory,omitempty"`

	// IsSaveSameDirectory ソースビデオファイルと同じ場所に保存するか
	IsSaveSameDirectory *bool `json:"isSaveSameDirectory,omitempty"`

	// Mode エンコードプリセット名 config encode の name
	Mode string `json:"mode"`

	// ParentDir 親ディレクトリ名 config recorded の name, isSaveSameDirectory が false の場合は必須
	ParentDir *string `json:"parentDir,omitempty"`

	// RecordedId 録画済み番組 id
	RecordedId RecordedId `json:"recordedId"`

	// RemoveOriginal 元ファイルを削除するか
	RemoveOriginal bool `json:"removeOriginal"`

	// SourceVideoFileId ビデオファイル id
	SourceVideoFileId VideoFileId `json:"sourceVideoFileId"`
}

// AddRecordedTagOption 録画タグ追加プション
type AddRecordedTagOption struct {
	// Color 色
	Color string `json:"color"`

	// Name タグ名
	Name string `json:"name"`
}

// AddRuleOption ルール追加プション
type AddRuleOption struct {
	// EncodeOption 予約エンコードオプション
	EncodeOption *ReserveEncodedOption `json:"encodeOption,omitempty"`

	// IsTimeSpecification 時刻指定予約か
	IsTimeSpecification bool `json:"isTimeSpecification"`

	// ReserveOption ルール予約オプション
	ReserveOption RuleReserveOption `json:"reserveOption"`

	// SaveOption 予約保存オプション
	SaveOption *ReserveSaveOption `json:"saveOption,omitempty"`

	// SearchOption ルール検索オプション
	SearchOption RuleSearchOption `json:"searchOption"`
}

// AddedEncode エンコード追加成功応答データ
type AddedEncode struct {
	// EncodeId エンコード id
	EncodeId EncodeId `json:"encodeId"`
}

// AddedRecordedTag タグ追加成功応答データ
type AddedRecordedTag struct {
	// TagId 録画 tag id
	TagId RecordedTagId `json:"tagId"`
}

// AddedReserve 予約成功応答データ
type AddedReserve struct {
	// ReserveId 予約 id
	ReserveId ReserveId `json:"reserveId"`
}

// AddedRule ルール追加成功応答データ
type AddedRule struct {
	// RuleId ルール id
	RuleId RuleId `json:"ruleId"`
}

// ChannelId 放送局 id
type ChannelId = int

// ChannelItem チャンネル情報
type ChannelItem struct {
	Channel string `json:"channel"`

	// ChannelType 放送波タイプ
	ChannelType ChannelType `json:"channelType"`

	// HalfWidthName 放送局名(半角)
	HalfWidthName string `json:"halfWidthName"`

	// HasLogoData ロゴデータを持っているか
	HasLogoData bool `json:"hasLogoData"`

	// Id 放送局 id
	Id ChannelId `json:"id"`

	// Name 放送局名
	Name string `json:"name"`

	// NetworkId network id
	NetworkId NetworkId `json:"networkId"`

	// ServiceId service id
	ServiceId ServiceId `json:"serviceId"`
}

// ChannelItems defines model for ChannelItems.
type ChannelItems = []ChannelItem

// ChannelType 放送波タイプ
type ChannelType string

// Config コンフィグ
type Config struct {
	// Broadcast 有効な放送波情報
	Broadcast struct {
		BS  bool `json:"BS"`
		CS  bool `json:"CS"`
		GR  bool `json:"GR"`
		SKY bool `json:"SKY"`
	} `json:"broadcast"`

	// Encode エンコードモード
	Encode []string `json:"encode"`

	// IsEnableEncodedRecordedStream 録画済みのエンコード済みファイルのストリーミングが有効か
	IsEnableEncodedRecordedStream bool `json:"isEnableEncodedRecordedStream"`

	// IsEnableLiveStream ライブ視聴が有効か
	IsEnableLiveStream bool `json:"isEnableLiveStream"`

	// IsEnableTSRecordedStream 録画済みの TS ファイルのストリーミングが有効か
	IsEnableTSRecordedStream bool `json:"isEnableTSRecordedStream"`

	// KodiHosts kodi hosts
	KodiHosts *[]string `json:"kodiHosts,omitempty"`

	// Recorded 指定可能な録画ディレクトリ名
	Recorded []string `json:"recorded"`

	// SocketIOPort socket.io 通信で使用するポート
	SocketIOPort int `json:"socketIOPort"`

	// StreamConfig ストリーミング設定
	StreamConfig *struct {
		// Live ライブストリーミング設定
		Live *struct {
			// Hls ライブ HLS ストリーミング設定
			Hls *[]string `json:"hls,omitempty"`

			// M2ts ライブ M2TS ストリーミング設定
			M2ts *[]M2TSStreamParam `json:"m2ts,omitempty"`

			// M2tsll ライブ M2TS Low Latency (mpegts.js 用) ストリーミング設定
			M2tsll *[]string `json:"m2tsll,omitempty"`

			// Mp4 ライブ MP4 ストリーミング設定
			Mp4 *[]string `json:"mp4,omitempty"`

			// Webm ライブ WebM ストリーミング設定
			Webm *[]string `json:"webm,omitempty"`
		} `json:"live,omitempty"`

		// Recorded 録画済みストリーミング設定
		Recorded *struct {
			// Encoded 録画エンコード済みファイルのストリーミング設定
			Encoded *struct {
				// Hls 録画エンコード済みファイルの HLS ストリーミング設定
				Hls *[]string `json:"hls,omitempty"`

				// Mp4 録画エンコード済みファイルの MP4 ストリーミング設定
				Mp4 *[]string `json:"mp4,omitempty"`

				// Webm 録画エンコード済みファイルの WebM ストリーミング設定
				Webm *[]string `json:"webm,omitempty"`
			} `json:"encoded,omitempty"`

			// Ts 録画済み TS ファイルのストリーミング設定
			Ts *struct {
				// Hls 録画済み TS ファイルの HLS ストリーミング設定
				Hls *[]string `json:"hls,omitempty"`

				// Mp4 録画済み TS ファイルの MP4 ストリーミング設定
				Mp4 *[]string `json:"mp4,omitempty"`

				// Webm 録画済み TS ファイルの WebM ストリーミング設定
				Webm *[]string `json:"webm,omitempty"`
			} `json:"ts,omitempty"`
		} `json:"recorded,omitempty"`
	} `json:"streamConfig,omitempty"`

	// Urlscheme URL Scheme 情報
	Urlscheme struct {
		// Download URL Scheme
		Download URLSchemeInfo `json:"download"`

		// M2ts URL Scheme
		M2ts URLSchemeInfo `json:"m2ts"`

		// Video URL Scheme
		Video URLSchemeInfo `json:"video"`
	} `json:"urlscheme"`
}

// CreateNewRecordedOption 新規追加する録画番組情報
type CreateNewRecordedOption struct {
	// ChannelId 放送局 id
	ChannelId ChannelId `json:"channelId"`

	// Description 番組詳細
	Description *string `json:"description,omitempty"`

	// EndAt 時刻 (ms)
	EndAt UnixtimeMS `json:"endAt"`

	// Extended 番組拡張
	Extended *string `json:"extended,omitempty"`

	// Genre1 ジャンル
	Genre1 *ProgramGenreLv1 `json:"genre1,omitempty"`

	// Genre2 ジャンル
	Genre2 *ProgramGenreLv1 `json:"genre2,omitempty"`

	// Genre3 ジャンル
	Genre3 *ProgramGenreLv1 `json:"genre3,omitempty"`

	// Name 番組名
	Name string `json:"name"`

	// RuleId ルール id
	RuleId *RuleId `json:"ruleId,omitempty"`

	// StartAt 時刻 (ms)
	StartAt UnixtimeMS `json:"startAt"`

	// SubGenre1 サブジャンル
	SubGenre1 *ProgramGenreLv2 `json:"subGenre1,omitempty"`

	// SubGenre2 サブジャンル
	SubGenre2 *ProgramGenreLv2 `json:"subGenre2,omitempty"`

	// SubGenre3 サブジャンル
	SubGenre3 *ProgramGenreLv2 `json:"subGenre3,omitempty"`
}

// CreatedNewRecorded 録画番組情報の新規作成成功応答データ
type CreatedNewRecorded struct {
	// RecordedId 録画済み番組 id
	RecordedId RecordedId `json:"recordedId"`
}

// DropLogFile ドロップログファイル情報
type DropLogFile struct {
	// DropCnt ドロップカウント
	DropCnt int `json:"dropCnt"`

	// ErrorCnt エラーカウント
	ErrorCnt int `json:"errorCnt"`

	// Id ドロップログファイル id
	Id DropLogFileId `json:"id"`

	// ScramblingCnt スクランブルカウント
	ScramblingCnt int `json:"scramblingCnt"`
}

// DropLogFileId ドロップログファイル id
type DropLogFileId = int

// EditManualReserveOption 手動予約編集オプション
type EditManualReserveOption struct {
	// AllowEndLack 末尾切れを許すか
	AllowEndLack bool `json:"allowEndLack"`

	// EncodeOption 予約エンコードオプション
	EncodeOption *ReserveEncodedOption `json:"encodeOption,omitempty"`

	// SaveOption 予約保存オプション
	SaveOption *ReserveSaveOption `json:"saveOption,omitempty"`
	Tags       *[]RecordedTagId   `json:"tags,omitempty"`
}

// EncodeId エンコード id
type EncodeId = int

// EncodeInfo エンコード情報
type EncodeInfo struct {
	RunningItems []EncodeProgramItem `json:"runningItems"`
	WaitItems    []EncodeProgramItem `json:"waitItems"`
}

// EncodeProgramItem エンコードプログラム情報
type EncodeProgramItem struct {
	// Id エンコード id
	Id EncodeId `json:"id"`

	// Log ログ
	Log *string `json:"log,omitempty"`

	// Mode エンコード名
	Mode string `json:"mode"`

	// Percent 進捗
	Percent *float32 `json:"percent,omitempty"`

	// Recorded 録画番組情報
	Recorded RecordedItem `json:"recorded"`
}

// Error defines model for Error.
type Error struct {
	// Code HTTPステータスコード
	Code int32 `json:"code"`

	// Errors Error
	Errors *string `json:"errors,omitempty"`

	// Message エラーメッセージ
	Message string `json:"message"`
}

// Genre ジャンル設定
type Genre struct {
	// Genre ジャンル
	Genre ProgramGenreLv1 `json:"genre"`

	// SubGenre サブジャンル
	SubGenre *ProgramGenreLv2 `json:"subGenre,omitempty"`
}

// M2TSStreamParam M2TS形式ストリーミングパラメータ
type M2TSStreamParam struct {
	// IsUnconverted 無変換か
	IsUnconverted bool `json:"isUnconverted"`

	// Name 表示名
	Name string `json:"name"`
}

// ManualReserveOption 手動予約編集オプション
type ManualReserveOption = EditManualReserveOption

// NetworkId network id
type NetworkId = int

// ProgramAudioSamplingRate 番組オーディオサンプリングレート
type ProgramAudioSamplingRate int

// ProgramGenreLv1 ジャンル
type ProgramGenreLv1 = int

// ProgramGenreLv2 サブジャンル
type ProgramGenreLv2 = int

// ProgramId program id
type ProgramId = int

// ProgramVideoResolution 番組ビデオ解像度
type ProgramVideoResolution string

// ProgramVideoType 番組ビデオコーデック
type ProgramVideoType string

// RecordedChannelListItem recorded が持つ channelId のリスト
type RecordedChannelListItem struct {
	// ChannelId 放送局 id
	ChannelId ChannelId `json:"channelId"`

	// Cnt 録画数
	Cnt int `json:"cnt"`
}

// RecordedGenreListItem recorded が持つ genre のリスト
type RecordedGenreListItem struct {
	// Cnt 録画数
	Cnt int `json:"cnt"`

	// Genre ジャンル
	Genre ProgramGenreLv1 `json:"genre"`
}

// RecordedId 録画済み番組 id
type RecordedId = int

// RecordedItem 録画番組情報
type RecordedItem struct {
	AudioComponentType *int `json:"audioComponentType,omitempty"`

	// AudioSamplingRate 番組オーディオサンプリングレート
	AudioSamplingRate *ProgramAudioSamplingRate `json:"audioSamplingRate,omitempty"`

	// ChannelId 放送局 id
	ChannelId *ChannelId `json:"channelId,omitempty"`

	// Description 番組詳細
	Description *string `json:"description,omitempty"`

	// DropLog ドロップログファイル情報
	DropLog *DropLogFile `json:"dropLog,omitempty"`

	// EndAt 時刻 (ms)
	EndAt UnixtimeMS `json:"endAt"`

	// Extended 番組拡張
	Extended *string `json:"extended,omitempty"`

	// Genre1 ジャンル
	Genre1 *ProgramGenreLv1 `json:"genre1,omitempty"`

	// Genre2 ジャンル
	Genre2 *ProgramGenreLv1 `json:"genre2,omitempty"`

	// Genre3 ジャンル
	Genre3 *ProgramGenreLv1 `json:"genre3,omitempty"`

	// Id 録画済み番組 id
	Id RecordedId `json:"id"`

	// IsEncoding エンコード中か
	IsEncoding bool `json:"isEncoding"`

	// IsProtected 自動録画削除対象外か
	IsProtected bool `json:"isProtected"`

	// IsRecording 録画中か
	IsRecording bool `json:"isRecording"`

	// Name 番組名
	Name string `json:"name"`

	// ProgramId program id
	ProgramId *ProgramId `json:"programId,omitempty"`

	// RawExtended 番組拡張 (Mirakurun の extended)
	RawExtended *map[string]interface{} `json:"rawExtended,omitempty"`

	// RuleId ルール id
	RuleId *RuleId `json:"ruleId,omitempty"`

	// StartAt 時刻 (ms)
	StartAt UnixtimeMS `json:"startAt"`

	// SubGenre1 サブジャンル
	SubGenre1 *ProgramGenreLv2 `json:"subGenre1,omitempty"`

	// SubGenre2 サブジャンル
	SubGenre2 *ProgramGenreLv2 `json:"subGenre2,omitempty"`

	// SubGenre3 サブジャンル
	SubGenre3          *ProgramGenreLv2 `json:"subGenre3,omitempty"`
	Tags               *[]RecordedTag   `json:"tags,omitempty"`
	Thumbnails         *[]ThumbnailId   `json:"thumbnails,omitempty"`
	VideoComponentType *int             `json:"videoComponentType,omitempty"`
	VideoFiles         *[]VideoFile     `json:"videoFiles,omitempty"`

	// VideoResolution 番組ビデオ解像度
	VideoResolution    *ProgramVideoResolution `json:"videoResolution,omitempty"`
	VideoStreamContent *int                    `json:"videoStreamContent,omitempty"`

	// VideoType 番組ビデオコーデック
	VideoType *ProgramVideoType `json:"videoType,omitempty"`
}

// RecordedSearchOptions recorded が持つ検索オプション情報
type RecordedSearchOptions struct {
	Channels []RecordedChannelListItem `json:"channels"`
	Genres   []RecordedGenreListItem   `json:"genres"`
}

// RecordedTag タグ情報
type RecordedTag struct {
	// Color 色
	Color string `json:"color"`

	// Id 録画 tag id
	Id RecordedTagId `json:"id"`

	// Name タグ名
	Name string `json:"name"`
}

// RecordedTagId 録画 tag id
type RecordedTagId = int

// RecordedTags 録画タグ情報
type RecordedTags struct {
	Tags []RecordedTag `json:"tags"`

	// Total 予約総件数
	Total int `json:"total"`
}

// Records 録画情報
type Records struct {
	Records []RecordedItem `json:"records"`

	// Total 録画総件数
	Total int `json:"total"`
}

// RelateRecordedTagOption 録画番組とタグの関連付けオプション
type RelateRecordedTagOption struct {
	// RecordedId 録画済み番組 id
	RecordedId RecordedId `json:"recordedId"`
}

// ReserveCnts 予約カウント
type ReserveCnts struct {
	// Conflicts 競合予約数
	Conflicts int `json:"conflicts"`

	// Normal 通常予約数
	Normal int `json:"normal"`

	// Overlaps 重複予約数
	Overlaps int `json:"overlaps"`

	// Skips 競合予約数
	Skips int `json:"skips"`
}

// ReserveEncodedOption 予約エンコードオプション
type ReserveEncodedOption struct {
	// Directory1 エンコードモード1ディレクトリ
	Directory1 *string `json:"directory1,omitempty"`

	// Directory2 エンコードモード2ディレクトリ
	Directory2 *string `json:"directory2,omitempty"`

	// Directory3 エンコードモード3ディレクトリ
	Directory3 *string `json:"directory3,omitempty"`

	// EncodeParentDirectoryName1 エンコードモード1親ディレクトリ
	EncodeParentDirectoryName1 *string `json:"encodeParentDirectoryName1,omitempty"`

	// EncodeParentDirectoryName2 エンコードモード2親ディレクトリ
	EncodeParentDirectoryName2 *string `json:"encodeParentDirectoryName2,omitempty"`

	// EncodeParentDirectoryName3 エンコードモード3親ディレクトリ
	EncodeParentDirectoryName3 *string `json:"encodeParentDirectoryName3,omitempty"`

	// IsDeleteOriginalAfterEncode エンコード後に ts を削除するか
	IsDeleteOriginalAfterEncode bool `json:"isDeleteOriginalAfterEncode"`

	// Mode1 エンコードモード1
	Mode1 *string `json:"mode1,omitempty"`

	// Mode2 エンコードモード2
	Mode2 *string `json:"mode2,omitempty"`

	// Mode3 エンコードモード3
	Mode3 *string `json:"mode3,omitempty"`
}

// ReserveId 予約 id
type ReserveId = int

// ReserveItem 予約番組情報
type ReserveItem struct {
	AllowEndLack       bool `json:"allowEndLack"`
	AudioComponentType *int `json:"audioComponentType,omitempty"`

	// AudioSamplingRate 番組オーディオサンプリングレート
	AudioSamplingRate *ProgramAudioSamplingRate `json:"audioSamplingRate,omitempty"`

	// ChannelId 放送局 id
	ChannelId                  ChannelId `json:"channelId"`
	Description                *string   `json:"description,omitempty"`
	Directory                  *string   `json:"directory,omitempty"`
	EncodeDirectory1           *string   `json:"encodeDirectory1,omitempty"`
	EncodeDirectory2           *string   `json:"encodeDirectory2,omitempty"`
	EncodeDirectory3           *int      `json:"encodeDirectory3,omitempty"`
	EncodeMode1                *int      `json:"encodeMode1,omitempty"`
	EncodeMode2                *int      `json:"encodeMode2,omitempty"`
	EncodeMode3                *int      `json:"encodeMode3,omitempty"`
	EncodeParentDirectoryName1 *string   `json:"encodeParentDirectoryName1,omitempty"`
	EncodeParentDirectoryName2 *string   `json:"encodeParentDirectoryName2,omitempty"`
	EncodeParentDirectoryName3 *string   `json:"encodeParentDirectoryName3,omitempty"`

	// EndAt 時刻 (ms)
	EndAt    UnixtimeMS `json:"endAt"`
	Extended *string    `json:"extended,omitempty"`

	// Genre1 ジャンル
	Genre1 *ProgramGenreLv1 `json:"genre1,omitempty"`

	// Genre2 ジャンル
	Genre2 *ProgramGenreLv1 `json:"genre2,omitempty"`

	// Genre3 ジャンル
	Genre3 *ProgramGenreLv1 `json:"genre3,omitempty"`

	// Id 予約 id
	Id                          ReserveId `json:"id"`
	IsConflict                  bool      `json:"isConflict"`
	IsDeleteOriginalAfterEncode bool      `json:"isDeleteOriginalAfterEncode"`
	IsOverlap                   bool      `json:"isOverlap"`
	IsSkip                      bool      `json:"isSkip"`
	IsTimeSpecified             bool      `json:"isTimeSpecified"`
	Name                        string    `json:"name"`
	ParentDirectoryName         *string   `json:"parentDirectoryName,omitempty"`

	// ProgramId program id
	ProgramId      *ProgramId              `json:"programId,omitempty"`
	RawExtended    *map[string]interface{} `json:"rawExtended,omitempty"`
	RecordedFormat *string                 `json:"recordedFormat,omitempty"`

	// RuleId ルール id
	RuleId *RuleId `json:"ruleId,omitempty"`

	// StartAt 時刻 (ms)
	StartAt UnixtimeMS `json:"startAt"`

	// SubGenre1 サブジャンル
	SubGenre1 *ProgramGenreLv2 `json:"subGenre1,omitempty"`

	// SubGenre2 サブジャンル
	SubGenre2 *ProgramGenreLv2 `json:"subGenre2,omitempty"`

	// SubGenre3 サブジャンル
	SubGenre3          *ProgramGenreLv2 `json:"subGenre3,omitempty"`
	Tags               *[]RecordedTagId `json:"tags,omitempty"`
	VideoComponentType *int             `json:"videoComponentType,omitempty"`

	// VideoResolution 番組ビデオ解像度
	VideoResolution    *ProgramVideoResolution `json:"videoResolution,omitempty"`
	VideoStreamContent *int                    `json:"videoStreamContent,omitempty"`

	// VideoType 番組ビデオコーデック
	VideoType *ProgramVideoType `json:"videoType,omitempty"`
}

// ReserveListItem 予約リストitem
type ReserveListItem struct {
	// ProgramId program id
	ProgramId *ProgramId `json:"programId,omitempty"`

	// ReserveId 予約 id
	ReserveId ReserveId `json:"reserveId"`

	// RuleId ルール id
	RuleId *RuleId `json:"ruleId,omitempty"`
}

// ReserveLists 予約, 除外, 重複, 競合の reserveId のリスト
type ReserveLists struct {
	// Conflicts 予約リストitem
	Conflicts ReserveListItem `json:"conflicts"`

	// Normal 予約リストitem
	Normal ReserveListItem `json:"normal"`

	// Overlaps 予約リストitem
	Overlaps ReserveListItem `json:"overlaps"`

	// Skips 予約リストitem
	Skips ReserveListItem `json:"skips"`
}

// ReserveSaveOption 予約保存オプション
type ReserveSaveOption struct {
	// Directory 保存ディレクトリ
	Directory *string `json:"directory,omitempty"`

	// ParentDirectoryName 親保存ディレクトリ
	ParentDirectoryName *string `json:"parentDirectoryName,omitempty"`

	// RecordedFormat ファイル名フォーマット
	RecordedFormat *string `json:"recordedFormat,omitempty"`
}

// Reserves 予約情報
type Reserves struct {
	Reserves []ReserveItem `json:"reserves"`

	// Total 予約総件数
	Total int `json:"total"`
}

// Rule ルール追加プション
type Rule = AddRuleOption

// RuleId ルール id
type RuleId = int

// RuleKeywordInfo ルールキーワード検索結果
type RuleKeywordInfo struct {
	Items []RuleKeywordItem `json:"items"`
}

// RuleKeywordItem defines model for RuleKeywordItem.
type RuleKeywordItem struct {
	// Id ルール id
	Id      RuleId `json:"id"`
	Keyword string `json:"keyword"`
}

// RuleReserveOption ルール予約オプション
type RuleReserveOption struct {
	// AllowEndLack 末尾切れを許可するか
	AllowEndLack bool `json:"allowEndLack"`

	// AvoidDuplicate 録画済みの重複番組を排除するか
	AvoidDuplicate bool `json:"avoidDuplicate"`

	// Enable ルールが有効か
	Enable bool `json:"enable"`

	// PeriodToAvoidDuplicate 重複を避ける期間
	PeriodToAvoidDuplicate *int             `json:"periodToAvoidDuplicate,omitempty"`
	Tags                   *[]RecordedTagId `json:"tags,omitempty"`
}

// RuleSearchOption ルール検索オプション
type RuleSearchOption struct {
	// BS BS
	BS *bool `json:"BS,omitempty"`

	// CS CS
	CS *bool `json:"CS,omitempty"`

	// GR GR
	GR *bool `json:"GR,omitempty"`

	// SKY SKY
	SKY *bool `json:"SKY,omitempty"`

	// ChannelIds 放送局
	ChannelIds *[]ChannelId `json:"channelIds,omitempty"`

	// Description 概要 (検索キーワード)
	Description *bool `json:"description,omitempty"`

	// DurationMax 番組最大時間 (分)
	DurationMax *int `json:"durationMax,omitempty"`

	// DurationMin 番組最小時間 (分)
	DurationMin *int `json:"durationMin,omitempty"`

	// Extended 詳細 (検索キーワード)
	Extended *bool `json:"extended,omitempty"`

	// Genres ジャンル
	Genres *[]Genre `json:"genres,omitempty"`

	// IgnoreDescription 概要 (除外検索キーワード)
	IgnoreDescription *bool `json:"ignoreDescription,omitempty"`

	// IgnoreExtended 詳細 (除外検索キーワード)
	IgnoreExtended *bool `json:"ignoreExtended,omitempty"`

	// IgnoreKeyCS 大文字小文字区別有効化 (除外検索キーワード)
	IgnoreKeyCS *bool `json:"ignoreKeyCS,omitempty"`

	// IgnoreKeyRegExp 正規表現 (除外検索キーワード)
	IgnoreKeyRegExp *bool `json:"ignoreKeyRegExp,omitempty"`

	// IgnoreKeyword 除外検索キーワード
	IgnoreKeyword *string `json:"ignoreKeyword,omitempty"`

	// IgnoreName 番組名 (除外検索キーワード)
	IgnoreName *bool `json:"ignoreName,omitempty"`

	// IsFree 無料放送か
	IsFree *bool `json:"isFree,omitempty"`

	// KeyCS 大文字小文字区別有効化 (検索キーワード)
	KeyCS *bool `json:"keyCS,omitempty"`

	// KeyRegExp 正規表現 (検索キーワード)
	KeyRegExp *bool `json:"keyRegExp,omitempty"`

	// Keyword 検索キーワード
	Keyword *string `json:"keyword,omitempty"`

	// Name 番組名 (検索キーワード)
	Name *bool `json:"name,omitempty"`

	// SearchPeriods 検索対象期間
	SearchPeriods *[]SearchPeriod `json:"searchPeriods,omitempty"`

	// Times 時刻範囲
	Times *[]SearchTime `json:"times,omitempty"`
}

// Rules ルール情報
type Rules struct {
	Rules []Rule `json:"rules"`

	// Total ルール総件数
	Total int `json:"total"`
}

// Schedule 番組表データ
type Schedule struct {
	// Channel 番組表の放送局データ
	Channel  ScheduleChannleItem  `json:"channel"`
	Programs ScheduleProgramItems `json:"programs"`
}

// ScheduleChannleItem 番組表の放送局データ
type ScheduleChannleItem struct {
	// ChannelType 放送波タイプ
	ChannelType ChannelType `json:"channelType"`

	// HasLogoData ロゴデータを持っているか
	HasLogoData bool `json:"hasLogoData"`

	// Id 放送局 id
	Id ChannelId `json:"id"`

	// Name 放送局名
	Name string `json:"name"`

	// NetworkId network id
	NetworkId NetworkId `json:"networkId"`

	// RemoteControlKeyId リモコン番号
	RemoteControlKeyId *int `json:"remoteControlKeyId,omitempty"`

	// ServiceId service id
	ServiceId ServiceId `json:"serviceId"`
}

// ScheduleProgramItem 番組表の番組データ
type ScheduleProgramItem struct {
	AudioComponentType *int `json:"audioComponentType,omitempty"`

	// AudioSamplingRate 番組オーディオサンプリングレート
	AudioSamplingRate *ProgramAudioSamplingRate `json:"audioSamplingRate,omitempty"`

	// ChannelId 放送局 id
	ChannelId ChannelId `json:"channelId"`

	// Description 番組詳細
	Description *string `json:"description,omitempty"`

	// EndAt 時刻 (ms)
	EndAt UnixtimeMS `json:"endAt"`

	// Extended 番組拡張
	Extended *string `json:"extended,omitempty"`

	// Genre1 ジャンル
	Genre1 *ProgramGenreLv1 `json:"genre1,omitempty"`

	// Genre2 ジャンル
	Genre2 *ProgramGenreLv1 `json:"genre2,omitempty"`

	// Genre3 ジャンル
	Genre3 *ProgramGenreLv1 `json:"genre3,omitempty"`

	// Id program id
	Id ProgramId `json:"id"`

	// IsFree 無料放送か
	IsFree bool `json:"isFree"`

	// Name 番組名
	Name string `json:"name"`

	// RawExtended 番組拡張 (Mirakurun の extended)
	RawExtended *map[string]interface{} `json:"rawExtended,omitempty"`

	// StartAt 時刻 (ms)
	StartAt UnixtimeMS `json:"startAt"`

	// SubGenre1 サブジャンル
	SubGenre1 *ProgramGenreLv2 `json:"subGenre1,omitempty"`

	// SubGenre2 サブジャンル
	SubGenre2 *ProgramGenreLv2 `json:"subGenre2,omitempty"`

	// SubGenre3 サブジャンル
	SubGenre3          *ProgramGenreLv2 `json:"subGenre3,omitempty"`
	VideoComponentType *int             `json:"videoComponentType,omitempty"`

	// VideoResolution 番組ビデオ解像度
	VideoResolution    *ProgramVideoResolution `json:"videoResolution,omitempty"`
	VideoStreamContent *int                    `json:"videoStreamContent,omitempty"`

	// VideoType 番組ビデオコーデック
	VideoType *ProgramVideoType `json:"videoType,omitempty"`
}

// ScheduleProgramItems defines model for ScheduleProgramItems.
type ScheduleProgramItems = []ScheduleProgramItem

// ScheduleSearchOption 番組検索オプション
type ScheduleSearchOption struct {
	// IsHalfWidth 半角文字で取得するか
	IsHalfWidth bool `json:"isHalfWidth"`

	// Limit 検索結果取得最大件数
	Limit *float32 `json:"limit,omitempty"`

	// Option ルール検索オプション
	Option RuleSearchOption `json:"option"`
}

// Schedules defines model for Schedules.
type Schedules = []Schedule

// SearchPeriod 検索対象期間オプション
type SearchPeriod struct {
	// EndAt 時刻 (ms)
	EndAt UnixtimeMS `json:"endAt"`

	// StartAt 時刻 (ms)
	StartAt UnixtimeMS `json:"startAt"`
}

// SearchTime 時刻範囲指定オプション
type SearchTime struct {
	// Range 開始時刻からの時刻範囲(時) 1 - 23, 時刻予約の場合は秒で時間の長さを指定する 1 ~ 60 * 50 * 24 秒
	Range *int `json:"range,omitempty"`

	// Start 開始時刻 1 - 23, 時刻予約の場合は 0 時を 0 とした 0 ~ (60 * 50 * 24) - 1 秒までの開始時刻を指定する
	Start *int `json:"start,omitempty"`

	// Week 曜日指定 0x01, 0x02, 0x04, 0x08, 0x10, 0x20 ,0x40 が日〜土に対応するので and 演算で曜日を指定する
	Week int `json:"week"`
}

// SendVideoLinkToKodiOption kodiへビデオリンクを送信するときのオプション
type SendVideoLinkToKodiOption struct {
	// KodiName config の kodi の name
	KodiName string `json:"kodiName"`
}

// ServiceId service id
type ServiceId = int

// StartStreamInfo ストリーム開始情報
type StartStreamInfo struct {
	// StreamId ストリーム id
	StreamId StreamId `json:"streamId"`
}

// StorageInfo ストレージ情報
type StorageInfo struct {
	Items []StorageItem `json:"items"`
}

// StorageItem ストレージ使用状況
type StorageItem struct {
	// Available 空き容量 (byte)
	Available int `json:"available"`

	// Name ディスク名
	Name string `json:"name"`

	// Total 総容量 (byte)
	Total int `json:"total"`

	// Used 使用量 (byte)
	Used int `json:"used"`
}

// StreamId ストリーム id
type StreamId = int

// StreamInfo defines model for StreamInfo.
type StreamInfo struct {
	Items []StreamInfoItem `json:"items"`
}

// StreamInfoItem ストリーム情報
type StreamInfoItem struct {
	// ChannelId 放送局 id
	ChannelId ChannelId `json:"channelId"`

	// Description ストリーミング番組詳細
	Description *string `json:"description,omitempty"`

	// EndAt 時刻 (ms)
	EndAt UnixtimeMS `json:"endAt"`

	// Extended ストリーミング番組拡張
	Extended *string `json:"extended,omitempty"`

	// IsEnable 放送波が有効か (HLS 形式の場合有効)
	IsEnable bool `json:"isEnable"`

	// Mode ストリーミング設定
	Mode float32 `json:"mode"`

	// Name ストリーミング番組名
	Name string `json:"name"`

	// RecordedId 録画済み番組 id
	RecordedId *RecordedId `json:"recordedId,omitempty"`

	// StartAt 時刻 (ms)
	StartAt UnixtimeMS `json:"startAt"`

	// StreamId ストリーム id
	StreamId StreamId `json:"streamId"`

	// Type ストリームの種類
	Type StreamType `json:"type"`

	// VideoFileId ビデオファイル id
	VideoFileId *VideoFileId `json:"videoFileId,omitempty"`
}

// StreamType ストリームの種類
type StreamType string

// ThumbnailId サムネイル id
type ThumbnailId = int

// URLSchemeInfo URL Scheme
type URLSchemeInfo struct {
	Android *string `json:"android,omitempty"`
	Ios     *string `json:"ios,omitempty"`
	Mac     *string `json:"mac,omitempty"`
	Win     *string `json:"win,omitempty"`
}

// UnixtimeMS 時刻 (ms)
type UnixtimeMS = int

// UploadVideoFileOption ビデオファイルをアップロード
type UploadVideoFileOption struct {
	File openapi_types.File `json:"file"`

	// FileType ビデオファイル形式
	FileType VideoFileType `json:"fileType"`

	// ParentDirectoryName 親保存ディレクトリ
	ParentDirectoryName string `json:"parentDirectoryName"`

	// RecordedId 録画済み番組 id
	RecordedId RecordedId `json:"recordedId"`

	// SubDirectory 保存ディレクトリ
	SubDirectory *string `json:"subDirectory,omitempty"`

	// ViewName 表示名
	ViewName string `json:"viewName"`
}

// Version バージョン情報
type Version struct {
	Version string `json:"version"`
}

// VideoFile ビデオファイル情報
type VideoFile struct {
	// Filename ビデオファイル名
	Filename *string `json:"filename,omitempty"`

	// Id ビデオファイル id
	Id VideoFileId `json:"id"`

	// Name ビデオ名 (Web上の表示名)
	Name string `json:"name"`

	// Size ファイルサイズ
	Size int `json:"size"`

	// Type ビデオファイル形式
	Type VideoFileType `json:"type"`
}

// VideoFileDuration ビデオファイルの長さ
type VideoFileDuration struct {
	// Duration 動画長(秒)
	Duration float32 `json:"duration"`
}

// VideoFileId ビデオファイル id
type VideoFileId = int

// VideoFileType ビデオファイル形式
type VideoFileType string

// AddtionTime 時刻 (ms)
type AddtionTime = UnixtimeMS

// Days defines model for Days.
type Days = int

// EndAt 時刻 (ms)
type EndAt = UnixtimeMS

// GetReserveType defines model for GetReserveType.
type GetReserveType = interface{}

// IPTVDays defines model for IPTVDays.
type IPTVDays = int

// IPTVIsHalfWidth defines model for IPTVIsHalfWidth.
type IPTVIsHalfWidth = bool

// IsDownload defines model for IsDownload.
type IsDownload = bool

// IsFreeProgram defines model for IsFreeProgram.
type IsFreeProgram = bool

// IsHalfWidth defines model for IsHalfWidth.
type IsHalfWidth = bool

// IsReverse defines model for IsReverse.
type IsReverse = bool

// Limit defines model for Limit.
type Limit = int

// LogFileMaxSize defines model for LogFileMaxSize.
type LogFileMaxSize = int

// NeedsRawExtended defines model for NeedsRawExtended.
type NeedsRawExtended = bool

// Offset defines model for Offset.
type Offset = int

// PathChannelId 放送局 id
type PathChannelId = ChannelId

// PathDropLogFileId defines model for PathDropLogFileId.
type PathDropLogFileId = int

// PathEncodeId defines model for PathEncodeId.
type PathEncodeId = int

// PathProgramId program id
type PathProgramId = ProgramId

// PathRecordedId defines model for PathRecordedId.
type PathRecordedId = int

// PathRecordedTagId defines model for PathRecordedTagId.
type PathRecordedTagId = int

// PathReserveId defines model for PathReserveId.
type PathReserveId = int

// PathRuleId defines model for PathRuleId.
type PathRuleId = int

// PathStreamId ストリーム id
type PathStreamId = StreamId

// PathThumbnailId defines model for PathThumbnailId.
type PathThumbnailId = int

// PathVideoFileId defines model for PathVideoFileId.
type PathVideoFileId = int

// QueryChannelId 放送局 id
type QueryChannelId = ChannelId

// QueryExcludeRecordedTagId defines model for QueryExcludeRecordedTagId.
type QueryExcludeRecordedTagId = []string

// QueryHasOriginalFile defines model for QueryHasOriginalFile.
type QueryHasOriginalFile = bool

// QueryKeyword defines model for QueryKeyword.
type QueryKeyword = string

// QueryName defines model for QueryName.
type QueryName = string

// QueryProgramGenre ジャンル
type QueryProgramGenre = ProgramGenreLv1

// QueryRecordedId 録画済み番組 id
type QueryRecordedId = RecordedId

// QueryRuleId ルール id
type QueryRuleId = RuleId

// StartAt 時刻 (ms)
type StartAt = UnixtimeMS

// StreamMode defines model for StreamMode.
type StreamMode = int

// StreamPlayPosition defines model for StreamPlayPosition.
type StreamPlayPosition = int

// RequiredBS defines model for requiredBS.
type RequiredBS = bool

// RequiredCS defines model for requiredCS.
type RequiredCS = bool

// RequiredGR defines model for requiredGR.
type RequiredGR = bool

// RequiredSKY defines model for requiredSKY.
type RequiredSKY = bool

// GetDropLogsDropLogFileIdParams defines parameters for GetDropLogsDropLogFileId.
type GetDropLogsDropLogFileIdParams struct {
	// Maxsize ファイル最大サイズ (kByte)
	Maxsize *LogFileMaxSize `form:"maxsize,omitempty" json:"maxsize,omitempty"`
}

// GetEncodeParams defines parameters for GetEncode.
type GetEncodeParams struct {
	// IsHalfWidth 半角文字で取得するか
	IsHalfWidth IsHalfWidth `form:"isHalfWidth" json:"isHalfWidth"`
}

// GetIptvChannelM3u8Params defines parameters for GetIptvChannelM3u8.
type GetIptvChannelM3u8Params struct {
	// IsHalfWidth 半角文字で取得するか
	IsHalfWidth *IPTVIsHalfWidth `form:"isHalfWidth,omitempty" json:"isHalfWidth,omitempty"`

	// Mode ストリーミング設定
	Mode StreamMode `form:"mode" json:"mode"`
}

// GetIptvEpgXmlParams defines parameters for GetIptvEpgXml.
type GetIptvEpgXmlParams struct {
	// IsHalfWidth 半角文字で取得するか
	IsHalfWidth *IPTVIsHalfWidth `form:"isHalfWidth,omitempty" json:"isHalfWidth,omitempty"`

	// Days 取得日数
	Days *IPTVDays `form:"days,omitempty" json:"days,omitempty"`
}

// GetRecordedParams defines parameters for GetRecorded.
type GetRecordedParams struct {
	// IsHalfWidth 半角文字で取得するか
	IsHalfWidth IsHalfWidth `form:"isHalfWidth" json:"isHalfWidth"`

	// Offset offset
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit limit
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// IsReverse 逆順で取得するか
	IsReverse *IsReverse `form:"isReverse,omitempty" json:"isReverse,omitempty"`

	// RuleId ルールid
	RuleId *QueryRuleId `form:"ruleId,omitempty" json:"ruleId,omitempty"`

	// ChannelId 放送局 id
	ChannelId *QueryChannelId `form:"channelId,omitempty" json:"channelId,omitempty"`

	// Genre ジャンル
	Genre *QueryProgramGenre `form:"genre,omitempty" json:"genre,omitempty"`

	// Keyword キーワード
	Keyword *QueryKeyword `form:"keyword,omitempty" json:"keyword,omitempty"`

	// HasOriginalFile オリジナルファイルを含むか
	HasOriginalFile *QueryHasOriginalFile `form:"hasOriginalFile,omitempty" json:"hasOriginalFile,omitempty"`
}

// GetRecordedRecordedIdParams defines parameters for GetRecordedRecordedId.
type GetRecordedRecordedIdParams struct {
	// IsHalfWidth 半角文字で取得するか
	IsHalfWidth IsHalfWidth `form:"isHalfWidth" json:"isHalfWidth"`
}

// GetRecordingParams defines parameters for GetRecording.
type GetRecordingParams struct {
	// Offset offset
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit limit
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// IsHalfWidth 半角文字で取得するか
	IsHalfWidth IsHalfWidth `form:"isHalfWidth" json:"isHalfWidth"`
}

// GetReservesParams defines parameters for GetReserves.
type GetReservesParams struct {
	// Offset offset
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit limit
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// Type 予約情報取得タイプ
	Type *GetReserveType `form:"type,omitempty" json:"type,omitempty"`

	// IsHalfWidth 半角文字で取得するか
	IsHalfWidth IsHalfWidth `form:"isHalfWidth" json:"isHalfWidth"`

	// RuleId ルールid
	RuleId *QueryRuleId `form:"ruleId,omitempty" json:"ruleId,omitempty"`
}

// GetReservesListsParams defines parameters for GetReservesLists.
type GetReservesListsParams struct {
	// StartAt 開始時刻
	StartAt StartAt `form:"startAt" json:"startAt"`

	// EndAt 終了時刻
	EndAt EndAt `form:"endAt" json:"endAt"`
}

// GetReservesReserveIdParams defines parameters for GetReservesReserveId.
type GetReservesReserveIdParams struct {
	// IsHalfWidth 半角文字で取得するか
	IsHalfWidth IsHalfWidth `form:"isHalfWidth" json:"isHalfWidth"`
}

// GetRulesParams defines parameters for GetRules.
type GetRulesParams struct {
	// Offset offset
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit limit
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// Type 予約情報取得タイプ
	Type *GetReserveType `form:"type,omitempty" json:"type,omitempty"`

	// Keyword キーワード
	Keyword *QueryKeyword `form:"keyword,omitempty" json:"keyword,omitempty"`
}

// GetRulesKeywordParams defines parameters for GetRulesKeyword.
type GetRulesKeywordParams struct {
	// Offset offset
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit limit
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// Keyword キーワード
	Keyword *QueryKeyword `form:"keyword,omitempty" json:"keyword,omitempty"`
}

// GetSchedulesParams defines parameters for GetSchedules.
type GetSchedulesParams struct {
	// StartAt 開始時刻
	StartAt StartAt `form:"startAt" json:"startAt"`

	// EndAt 終了時刻
	EndAt EndAt `form:"endAt" json:"endAt"`

	// IsHalfWidth 半角文字で取得するか
	IsHalfWidth IsHalfWidth `form:"isHalfWidth" json:"isHalfWidth"`

	// NeedsRawExtended rawExtended が必要か
	NeedsRawExtended *NeedsRawExtended `form:"needsRawExtended,omitempty" json:"needsRawExtended,omitempty"`

	// IsFree 無料放送のみ取得するか (true: 無料放送, false: 有料放送, 無指定: 全て)
	IsFree *IsFreeProgram `form:"isFree,omitempty" json:"isFree,omitempty"`

	// GR GR
	GR RequiredGR `form:"GR" json:"GR"`

	// BS BS
	BS RequiredBS `form:"BS" json:"BS"`

	// CS CS
	CS RequiredCS `form:"CS" json:"CS"`

	// SKY SKY
	SKY RequiredSKY `form:"SKY" json:"SKY"`
}

// GetSchedulesBroadcastingParams defines parameters for GetSchedulesBroadcasting.
type GetSchedulesBroadcastingParams struct {
	// Time 追加時間 (ms)
	Time *AddtionTime `form:"time,omitempty" json:"time,omitempty"`

	// IsHalfWidth 半角文字で取得するか
	IsHalfWidth IsHalfWidth `form:"isHalfWidth" json:"isHalfWidth"`
}

// GetSchedulesDetailProgramIdParams defines parameters for GetSchedulesDetailProgramId.
type GetSchedulesDetailProgramIdParams struct {
	// IsHalfWidth 半角文字で取得するか
	IsHalfWidth IsHalfWidth `form:"isHalfWidth" json:"isHalfWidth"`
}

// GetSchedulesChannelIdParams defines parameters for GetSchedulesChannelId.
type GetSchedulesChannelIdParams struct {
	// StartAt 開始時刻
	StartAt StartAt `form:"startAt" json:"startAt"`

	// Days 取得日数
	Days Days `form:"days" json:"days"`

	// IsHalfWidth 半角文字で取得するか
	IsHalfWidth IsHalfWidth `form:"isHalfWidth" json:"isHalfWidth"`

	// NeedsRawExtended rawExtended が必要か
	NeedsRawExtended *NeedsRawExtended `form:"needsRawExtended,omitempty" json:"needsRawExtended,omitempty"`

	// IsFree 無料放送のみ取得するか (true: 無料放送, false: 有料放送, 無指定: 全て)
	IsFree *IsFreeProgram `form:"isFree,omitempty" json:"isFree,omitempty"`
}

// GetStreamsParams defines parameters for GetStreams.
type GetStreamsParams struct {
	// IsHalfWidth 半角文字で取得するか
	IsHalfWidth IsHalfWidth `form:"isHalfWidth" json:"isHalfWidth"`
}

// GetStreamsLiveChannelIdHlsParams defines parameters for GetStreamsLiveChannelIdHls.
type GetStreamsLiveChannelIdHlsParams struct {
	// Mode ストリーミング設定
	Mode StreamMode `form:"mode" json:"mode"`
}

// GetStreamsLiveChannelIdM2tsParams defines parameters for GetStreamsLiveChannelIdM2ts.
type GetStreamsLiveChannelIdM2tsParams struct {
	// Mode ストリーミング設定
	Mode StreamMode `form:"mode" json:"mode"`
}

// GetStreamsLiveChannelIdM2tsPlaylistParams defines parameters for GetStreamsLiveChannelIdM2tsPlaylist.
type GetStreamsLiveChannelIdM2tsPlaylistParams struct {
	// Mode ストリーミング設定
	Mode StreamMode `form:"mode" json:"mode"`
}

// GetStreamsLiveChannelIdM2tsllParams defines parameters for GetStreamsLiveChannelIdM2tsll.
type GetStreamsLiveChannelIdM2tsllParams struct {
	// Mode ストリーミング設定
	Mode StreamMode `form:"mode" json:"mode"`
}

// GetStreamsLiveChannelIdMp4Params defines parameters for GetStreamsLiveChannelIdMp4.
type GetStreamsLiveChannelIdMp4Params struct {
	// Mode ストリーミング設定
	Mode StreamMode `form:"mode" json:"mode"`
}

// GetStreamsLiveChannelIdWebmParams defines parameters for GetStreamsLiveChannelIdWebm.
type GetStreamsLiveChannelIdWebmParams struct {
	// Mode ストリーミング設定
	Mode StreamMode `form:"mode" json:"mode"`
}

// GetStreamsRecordedVideoFileIdHlsParams defines parameters for GetStreamsRecordedVideoFileIdHls.
type GetStreamsRecordedVideoFileIdHlsParams struct {
	// Ss 再生位置
	Ss StreamPlayPosition `form:"ss" json:"ss"`

	// Mode ストリーミング設定
	Mode StreamMode `form:"mode" json:"mode"`
}

// GetStreamsRecordedVideoFileIdMp4Params defines parameters for GetStreamsRecordedVideoFileIdMp4.
type GetStreamsRecordedVideoFileIdMp4Params struct {
	// Ss 再生位置
	Ss StreamPlayPosition `form:"ss" json:"ss"`

	// Mode ストリーミング設定
	Mode StreamMode `form:"mode" json:"mode"`
}

// GetStreamsRecordedVideoFileIdWebmParams defines parameters for GetStreamsRecordedVideoFileIdWebm.
type GetStreamsRecordedVideoFileIdWebmParams struct {
	// Ss 再生位置
	Ss StreamPlayPosition `form:"ss" json:"ss"`

	// Mode ストリーミング設定
	Mode StreamMode `form:"mode" json:"mode"`
}

// GetTagsParams defines parameters for GetTags.
type GetTagsParams struct {
	// Offset offset
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit limit
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// Name name
	Name *QueryName `form:"name,omitempty" json:"name,omitempty"`

	// ExcludeTagId 除外する RecordedTagId
	ExcludeTagId *QueryExcludeRecordedTagId `form:"excludeTagId,omitempty" json:"excludeTagId,omitempty"`
}

// DeleteTagsTagIdRelateParams defines parameters for DeleteTagsTagIdRelate.
type DeleteTagsTagIdRelateParams struct {
	// RecordedId recorded id
	RecordedId *QueryRecordedId `form:"recordedId,omitempty" json:"recordedId,omitempty"`
}

// GetVideosVideoFileIdParams defines parameters for GetVideosVideoFileId.
type GetVideosVideoFileIdParams struct {
	// IsDownload ファイルをダウンロードするか
	IsDownload *IsDownload `form:"isDownload,omitempty" json:"isDownload,omitempty"`
}

// PostEncodeJSONRequestBody defines body for PostEncode for application/json ContentType.
type PostEncodeJSONRequestBody = AddManualEncodeProgramOption

// PostRecordedJSONRequestBody defines body for PostRecorded for application/json ContentType.
type PostRecordedJSONRequestBody = CreateNewRecordedOption

// PostReservesJSONRequestBody defines body for PostReserves for application/json ContentType.
type PostReservesJSONRequestBody = ManualReserveOption

// PutReservesReserveIdJSONRequestBody defines body for PutReservesReserveId for application/json ContentType.
type PutReservesReserveIdJSONRequestBody = EditManualReserveOption

// PostRulesJSONRequestBody defines body for PostRules for application/json ContentType.
type PostRulesJSONRequestBody = AddRuleOption

// PostRulesKeywordJSONRequestBody defines body for PostRulesKeyword for application/json ContentType.
type PostRulesKeywordJSONRequestBody = AddRuleOption

// PutRulesRuleIdJSONRequestBody defines body for PutRulesRuleId for application/json ContentType.
type PutRulesRuleIdJSONRequestBody = AddRuleOption

// PostSchedulesSearchJSONRequestBody defines body for PostSchedulesSearch for application/json ContentType.
type PostSchedulesSearchJSONRequestBody = ScheduleSearchOption

// PostTagsJSONRequestBody defines body for PostTags for application/json ContentType.
type PostTagsJSONRequestBody = AddRecordedTagOption

// PutTagsTagIdJSONRequestBody defines body for PutTagsTagId for application/json ContentType.
type PutTagsTagIdJSONRequestBody = AddRecordedTagOption

// PutTagsTagIdRelateJSONRequestBody defines body for PutTagsTagIdRelate for application/json ContentType.
type PutTagsTagIdRelateJSONRequestBody = RelateRecordedTagOption

// PostVideosUploadMultipartRequestBody defines body for PostVideosUpload for multipart/form-data ContentType.
type PostVideosUploadMultipartRequestBody = UploadVideoFileOption

// PostVideosVideoFileIdKodiJSONRequestBody defines body for PostVideosVideoFileIdKodi for application/json ContentType.
type PostVideosVideoFileIdKodiJSONRequestBody = SendVideoLinkToKodiOption

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetChannels request
	GetChannels(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetChannelsChannelIdLogo request
	GetChannelsChannelIdLogo(ctx context.Context, channelId PathChannelId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetConfig request
	GetConfig(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDropLogsDropLogFileId request
	GetDropLogsDropLogFileId(ctx context.Context, dropLogFileId PathDropLogFileId, params *GetDropLogsDropLogFileIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetEncode request
	GetEncode(ctx context.Context, params *GetEncodeParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostEncodeWithBody request with any body
	PostEncodeWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostEncode(ctx context.Context, body PostEncodeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteEncodeEncodeId request
	DeleteEncodeEncodeId(ctx context.Context, encodeId PathEncodeId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetIptvChannelM3u8 request
	GetIptvChannelM3u8(ctx context.Context, params *GetIptvChannelM3u8Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetIptvEpgXml request
	GetIptvEpgXml(ctx context.Context, params *GetIptvEpgXmlParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRecorded request
	GetRecorded(ctx context.Context, params *GetRecordedParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostRecordedWithBody request with any body
	PostRecordedWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostRecorded(ctx context.Context, body PostRecordedJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostRecordedCleanup request
	PostRecordedCleanup(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRecordedOptions request
	GetRecordedOptions(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteRecordedRecordedId request
	DeleteRecordedRecordedId(ctx context.Context, recordedId PathRecordedId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRecordedRecordedId request
	GetRecordedRecordedId(ctx context.Context, recordedId PathRecordedId, params *GetRecordedRecordedIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteRecordedRecordedIdEncode request
	DeleteRecordedRecordedIdEncode(ctx context.Context, recordedId PathRecordedId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PutRecordedRecordedIdProtect request
	PutRecordedRecordedIdProtect(ctx context.Context, recordedId PathRecordedId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PutRecordedRecordedIdUnprotect request
	PutRecordedRecordedIdUnprotect(ctx context.Context, recordedId PathRecordedId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRecording request
	GetRecording(ctx context.Context, params *GetRecordingParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostRecordingResettimer request
	PostRecordingResettimer(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetReserves request
	GetReserves(ctx context.Context, params *GetReservesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostReservesWithBody request with any body
	PostReservesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostReserves(ctx context.Context, body PostReservesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetReservesCnts request
	GetReservesCnts(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetReservesLists request
	GetReservesLists(ctx context.Context, params *GetReservesListsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostReservesUpdate request
	PostReservesUpdate(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteReservesReserveId request
	DeleteReservesReserveId(ctx context.Context, reserveId PathReserveId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetReservesReserveId request
	GetReservesReserveId(ctx context.Context, reserveId PathReserveId, params *GetReservesReserveIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PutReservesReserveIdWithBody request with any body
	PutReservesReserveIdWithBody(ctx context.Context, reserveId PathReserveId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PutReservesReserveId(ctx context.Context, reserveId PathReserveId, body PutReservesReserveIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteReservesReserveIdOverlap request
	DeleteReservesReserveIdOverlap(ctx context.Context, reserveId PathReserveId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteReservesReserveIdSkip request
	DeleteReservesReserveIdSkip(ctx context.Context, reserveId PathReserveId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRules request
	GetRules(ctx context.Context, params *GetRulesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostRulesWithBody request with any body
	PostRulesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostRules(ctx context.Context, body PostRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRulesKeyword request
	GetRulesKeyword(ctx context.Context, params *GetRulesKeywordParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostRulesKeywordWithBody request with any body
	PostRulesKeywordWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostRulesKeyword(ctx context.Context, body PostRulesKeywordJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteRulesRuleId request
	DeleteRulesRuleId(ctx context.Context, ruleId PathRuleId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRulesRuleId request
	GetRulesRuleId(ctx context.Context, ruleId PathRuleId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PutRulesRuleIdWithBody request with any body
	PutRulesRuleIdWithBody(ctx context.Context, ruleId PathRuleId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PutRulesRuleId(ctx context.Context, ruleId PathRuleId, body PutRulesRuleIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PutRulesRuleIdDisable request
	PutRulesRuleIdDisable(ctx context.Context, ruleId PathRuleId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PutRulesRuleIdEnable request
	PutRulesRuleIdEnable(ctx context.Context, ruleId PathRuleId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSchedules request
	GetSchedules(ctx context.Context, params *GetSchedulesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSchedulesBroadcasting request
	GetSchedulesBroadcasting(ctx context.Context, params *GetSchedulesBroadcastingParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSchedulesDetailProgramId request
	GetSchedulesDetailProgramId(ctx context.Context, programId PathProgramId, params *GetSchedulesDetailProgramIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostSchedulesSearchWithBody request with any body
	PostSchedulesSearchWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostSchedulesSearch(ctx context.Context, body PostSchedulesSearchJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSchedulesChannelId request
	GetSchedulesChannelId(ctx context.Context, channelId PathChannelId, params *GetSchedulesChannelIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetStorages request
	GetStorages(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteStreams request
	DeleteStreams(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetStreams request
	GetStreams(ctx context.Context, params *GetStreamsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetStreamsLiveChannelIdHls request
	GetStreamsLiveChannelIdHls(ctx context.Context, channelId PathChannelId, params *GetStreamsLiveChannelIdHlsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetStreamsLiveChannelIdM2ts request
	GetStreamsLiveChannelIdM2ts(ctx context.Context, channelId PathChannelId, params *GetStreamsLiveChannelIdM2tsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetStreamsLiveChannelIdM2tsPlaylist request
	GetStreamsLiveChannelIdM2tsPlaylist(ctx context.Context, channelId PathChannelId, params *GetStreamsLiveChannelIdM2tsPlaylistParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetStreamsLiveChannelIdM2tsll request
	GetStreamsLiveChannelIdM2tsll(ctx context.Context, channelId PathChannelId, params *GetStreamsLiveChannelIdM2tsllParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetStreamsLiveChannelIdMp4 request
	GetStreamsLiveChannelIdMp4(ctx context.Context, channelId PathChannelId, params *GetStreamsLiveChannelIdMp4Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetStreamsLiveChannelIdWebm request
	GetStreamsLiveChannelIdWebm(ctx context.Context, channelId PathChannelId, params *GetStreamsLiveChannelIdWebmParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetStreamsRecordedVideoFileIdHls request
	GetStreamsRecordedVideoFileIdHls(ctx context.Context, videoFileId PathVideoFileId, params *GetStreamsRecordedVideoFileIdHlsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetStreamsRecordedVideoFileIdMp4 request
	GetStreamsRecordedVideoFileIdMp4(ctx context.Context, videoFileId PathVideoFileId, params *GetStreamsRecordedVideoFileIdMp4Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetStreamsRecordedVideoFileIdWebm request
	GetStreamsRecordedVideoFileIdWebm(ctx context.Context, videoFileId PathVideoFileId, params *GetStreamsRecordedVideoFileIdWebmParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteStreamsStreamId request
	DeleteStreamsStreamId(ctx context.Context, streamId PathStreamId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PutStreamsStreamIdKeep request
	PutStreamsStreamIdKeep(ctx context.Context, streamId PathStreamId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTags request
	GetTags(ctx context.Context, params *GetTagsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostTagsWithBody request with any body
	PostTagsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostTags(ctx context.Context, body PostTagsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteTagsTagId request
	DeleteTagsTagId(ctx context.Context, tagId PathRecordedTagId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PutTagsTagIdWithBody request with any body
	PutTagsTagIdWithBody(ctx context.Context, tagId PathRecordedTagId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PutTagsTagId(ctx context.Context, tagId PathRecordedTagId, body PutTagsTagIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteTagsTagIdRelate request
	DeleteTagsTagIdRelate(ctx context.Context, tagId PathRecordedTagId, params *DeleteTagsTagIdRelateParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PutTagsTagIdRelateWithBody request with any body
	PutTagsTagIdRelateWithBody(ctx context.Context, tagId PathRecordedTagId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PutTagsTagIdRelate(ctx context.Context, tagId PathRecordedTagId, body PutTagsTagIdRelateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostThumbnails request
	PostThumbnails(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostThumbnailsCleanup request
	PostThumbnailsCleanup(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetThumbnailsThumbnailId request
	GetThumbnailsThumbnailId(ctx context.Context, thumbnailId PathThumbnailId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetVersion request
	GetVersion(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostVideosUploadWithBody request with any body
	PostVideosUploadWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteVideosVideoFileId request
	DeleteVideosVideoFileId(ctx context.Context, videoFileId PathVideoFileId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetVideosVideoFileId request
	GetVideosVideoFileId(ctx context.Context, videoFileId PathVideoFileId, params *GetVideosVideoFileIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetVideosVideoFileIdDuration request
	GetVideosVideoFileIdDuration(ctx context.Context, videoFileId PathVideoFileId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostVideosVideoFileIdKodiWithBody request with any body
	PostVideosVideoFileIdKodiWithBody(ctx context.Context, videoFileId PathVideoFileId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostVideosVideoFileIdKodi(ctx context.Context, videoFileId PathVideoFileId, body PostVideosVideoFileIdKodiJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetVideosVideoFileIdPlaylist request
	GetVideosVideoFileIdPlaylist(ctx context.Context, videoFileId PathVideoFileId, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) GetChannels(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetChannelsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetChannelsChannelIdLogo(ctx context.Context, channelId PathChannelId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetChannelsChannelIdLogoRequest(c.Server, channelId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetConfig(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetConfigRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDropLogsDropLogFileId(ctx context.Context, dropLogFileId PathDropLogFileId, params *GetDropLogsDropLogFileIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDropLogsDropLogFileIdRequest(c.Server, dropLogFileId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetEncode(ctx context.Context, params *GetEncodeParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetEncodeRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostEncodeWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostEncodeRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostEncode(ctx context.Context, body PostEncodeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostEncodeRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteEncodeEncodeId(ctx context.Context, encodeId PathEncodeId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteEncodeEncodeIdRequest(c.Server, encodeId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetIptvChannelM3u8(ctx context.Context, params *GetIptvChannelM3u8Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetIptvChannelM3u8Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetIptvEpgXml(ctx context.Context, params *GetIptvEpgXmlParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetIptvEpgXmlRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRecorded(ctx context.Context, params *GetRecordedParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRecordedRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostRecordedWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostRecordedRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostRecorded(ctx context.Context, body PostRecordedJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostRecordedRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostRecordedCleanup(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostRecordedCleanupRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRecordedOptions(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRecordedOptionsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteRecordedRecordedId(ctx context.Context, recordedId PathRecordedId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteRecordedRecordedIdRequest(c.Server, recordedId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRecordedRecordedId(ctx context.Context, recordedId PathRecordedId, params *GetRecordedRecordedIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRecordedRecordedIdRequest(c.Server, recordedId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteRecordedRecordedIdEncode(ctx context.Context, recordedId PathRecordedId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteRecordedRecordedIdEncodeRequest(c.Server, recordedId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutRecordedRecordedIdProtect(ctx context.Context, recordedId PathRecordedId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutRecordedRecordedIdProtectRequest(c.Server, recordedId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutRecordedRecordedIdUnprotect(ctx context.Context, recordedId PathRecordedId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutRecordedRecordedIdUnprotectRequest(c.Server, recordedId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRecording(ctx context.Context, params *GetRecordingParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRecordingRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostRecordingResettimer(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostRecordingResettimerRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetReserves(ctx context.Context, params *GetReservesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetReservesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostReservesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostReservesRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostReserves(ctx context.Context, body PostReservesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostReservesRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetReservesCnts(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetReservesCntsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetReservesLists(ctx context.Context, params *GetReservesListsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetReservesListsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostReservesUpdate(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostReservesUpdateRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteReservesReserveId(ctx context.Context, reserveId PathReserveId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteReservesReserveIdRequest(c.Server, reserveId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetReservesReserveId(ctx context.Context, reserveId PathReserveId, params *GetReservesReserveIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetReservesReserveIdRequest(c.Server, reserveId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutReservesReserveIdWithBody(ctx context.Context, reserveId PathReserveId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutReservesReserveIdRequestWithBody(c.Server, reserveId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutReservesReserveId(ctx context.Context, reserveId PathReserveId, body PutReservesReserveIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutReservesReserveIdRequest(c.Server, reserveId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteReservesReserveIdOverlap(ctx context.Context, reserveId PathReserveId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteReservesReserveIdOverlapRequest(c.Server, reserveId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteReservesReserveIdSkip(ctx context.Context, reserveId PathReserveId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteReservesReserveIdSkipRequest(c.Server, reserveId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRules(ctx context.Context, params *GetRulesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRulesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostRulesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostRulesRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostRules(ctx context.Context, body PostRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostRulesRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRulesKeyword(ctx context.Context, params *GetRulesKeywordParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRulesKeywordRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostRulesKeywordWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostRulesKeywordRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostRulesKeyword(ctx context.Context, body PostRulesKeywordJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostRulesKeywordRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteRulesRuleId(ctx context.Context, ruleId PathRuleId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteRulesRuleIdRequest(c.Server, ruleId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRulesRuleId(ctx context.Context, ruleId PathRuleId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRulesRuleIdRequest(c.Server, ruleId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutRulesRuleIdWithBody(ctx context.Context, ruleId PathRuleId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutRulesRuleIdRequestWithBody(c.Server, ruleId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutRulesRuleId(ctx context.Context, ruleId PathRuleId, body PutRulesRuleIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutRulesRuleIdRequest(c.Server, ruleId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutRulesRuleIdDisable(ctx context.Context, ruleId PathRuleId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutRulesRuleIdDisableRequest(c.Server, ruleId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutRulesRuleIdEnable(ctx context.Context, ruleId PathRuleId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutRulesRuleIdEnableRequest(c.Server, ruleId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSchedules(ctx context.Context, params *GetSchedulesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSchedulesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSchedulesBroadcasting(ctx context.Context, params *GetSchedulesBroadcastingParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSchedulesBroadcastingRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSchedulesDetailProgramId(ctx context.Context, programId PathProgramId, params *GetSchedulesDetailProgramIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSchedulesDetailProgramIdRequest(c.Server, programId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSchedulesSearchWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSchedulesSearchRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSchedulesSearch(ctx context.Context, body PostSchedulesSearchJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSchedulesSearchRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSchedulesChannelId(ctx context.Context, channelId PathChannelId, params *GetSchedulesChannelIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSchedulesChannelIdRequest(c.Server, channelId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetStorages(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetStoragesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteStreams(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteStreamsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetStreams(ctx context.Context, params *GetStreamsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetStreamsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetStreamsLiveChannelIdHls(ctx context.Context, channelId PathChannelId, params *GetStreamsLiveChannelIdHlsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetStreamsLiveChannelIdHlsRequest(c.Server, channelId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetStreamsLiveChannelIdM2ts(ctx context.Context, channelId PathChannelId, params *GetStreamsLiveChannelIdM2tsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetStreamsLiveChannelIdM2tsRequest(c.Server, channelId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetStreamsLiveChannelIdM2tsPlaylist(ctx context.Context, channelId PathChannelId, params *GetStreamsLiveChannelIdM2tsPlaylistParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetStreamsLiveChannelIdM2tsPlaylistRequest(c.Server, channelId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetStreamsLiveChannelIdM2tsll(ctx context.Context, channelId PathChannelId, params *GetStreamsLiveChannelIdM2tsllParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetStreamsLiveChannelIdM2tsllRequest(c.Server, channelId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetStreamsLiveChannelIdMp4(ctx context.Context, channelId PathChannelId, params *GetStreamsLiveChannelIdMp4Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetStreamsLiveChannelIdMp4Request(c.Server, channelId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetStreamsLiveChannelIdWebm(ctx context.Context, channelId PathChannelId, params *GetStreamsLiveChannelIdWebmParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetStreamsLiveChannelIdWebmRequest(c.Server, channelId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetStreamsRecordedVideoFileIdHls(ctx context.Context, videoFileId PathVideoFileId, params *GetStreamsRecordedVideoFileIdHlsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetStreamsRecordedVideoFileIdHlsRequest(c.Server, videoFileId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetStreamsRecordedVideoFileIdMp4(ctx context.Context, videoFileId PathVideoFileId, params *GetStreamsRecordedVideoFileIdMp4Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetStreamsRecordedVideoFileIdMp4Request(c.Server, videoFileId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetStreamsRecordedVideoFileIdWebm(ctx context.Context, videoFileId PathVideoFileId, params *GetStreamsRecordedVideoFileIdWebmParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetStreamsRecordedVideoFileIdWebmRequest(c.Server, videoFileId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteStreamsStreamId(ctx context.Context, streamId PathStreamId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteStreamsStreamIdRequest(c.Server, streamId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutStreamsStreamIdKeep(ctx context.Context, streamId PathStreamId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutStreamsStreamIdKeepRequest(c.Server, streamId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTags(ctx context.Context, params *GetTagsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTagsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostTagsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostTagsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostTags(ctx context.Context, body PostTagsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostTagsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteTagsTagId(ctx context.Context, tagId PathRecordedTagId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteTagsTagIdRequest(c.Server, tagId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutTagsTagIdWithBody(ctx context.Context, tagId PathRecordedTagId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutTagsTagIdRequestWithBody(c.Server, tagId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutTagsTagId(ctx context.Context, tagId PathRecordedTagId, body PutTagsTagIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutTagsTagIdRequest(c.Server, tagId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteTagsTagIdRelate(ctx context.Context, tagId PathRecordedTagId, params *DeleteTagsTagIdRelateParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteTagsTagIdRelateRequest(c.Server, tagId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutTagsTagIdRelateWithBody(ctx context.Context, tagId PathRecordedTagId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutTagsTagIdRelateRequestWithBody(c.Server, tagId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutTagsTagIdRelate(ctx context.Context, tagId PathRecordedTagId, body PutTagsTagIdRelateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutTagsTagIdRelateRequest(c.Server, tagId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostThumbnails(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostThumbnailsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostThumbnailsCleanup(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostThumbnailsCleanupRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetThumbnailsThumbnailId(ctx context.Context, thumbnailId PathThumbnailId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetThumbnailsThumbnailIdRequest(c.Server, thumbnailId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetVersion(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetVersionRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostVideosUploadWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostVideosUploadRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteVideosVideoFileId(ctx context.Context, videoFileId PathVideoFileId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteVideosVideoFileIdRequest(c.Server, videoFileId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetVideosVideoFileId(ctx context.Context, videoFileId PathVideoFileId, params *GetVideosVideoFileIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetVideosVideoFileIdRequest(c.Server, videoFileId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetVideosVideoFileIdDuration(ctx context.Context, videoFileId PathVideoFileId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetVideosVideoFileIdDurationRequest(c.Server, videoFileId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostVideosVideoFileIdKodiWithBody(ctx context.Context, videoFileId PathVideoFileId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostVideosVideoFileIdKodiRequestWithBody(c.Server, videoFileId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostVideosVideoFileIdKodi(ctx context.Context, videoFileId PathVideoFileId, body PostVideosVideoFileIdKodiJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostVideosVideoFileIdKodiRequest(c.Server, videoFileId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetVideosVideoFileIdPlaylist(ctx context.Context, videoFileId PathVideoFileId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetVideosVideoFileIdPlaylistRequest(c.Server, videoFileId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewGetChannelsRequest generates requests for GetChannels
func NewGetChannelsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/channels")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetChannelsChannelIdLogoRequest generates requests for GetChannelsChannelIdLogo
func NewGetChannelsChannelIdLogoRequest(server string, channelId PathChannelId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "channelId", runtime.ParamLocationPath, channelId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/channels/%s/logo", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetConfigRequest generates requests for GetConfig
func NewGetConfigRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/config")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDropLogsDropLogFileIdRequest generates requests for GetDropLogsDropLogFileId
func NewGetDropLogsDropLogFileIdRequest(server string, dropLogFileId PathDropLogFileId, params *GetDropLogsDropLogFileIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "dropLogFileId", runtime.ParamLocationPath, dropLogFileId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/dropLogs/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Maxsize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxsize", runtime.ParamLocationQuery, *params.Maxsize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetEncodeRequest generates requests for GetEncode
func NewGetEncodeRequest(server string, params *GetEncodeParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/encode")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isHalfWidth", runtime.ParamLocationQuery, params.IsHalfWidth); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostEncodeRequest calls the generic PostEncode builder with application/json body
func NewPostEncodeRequest(server string, body PostEncodeJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostEncodeRequestWithBody(server, "application/json", bodyReader)
}

// NewPostEncodeRequestWithBody generates requests for PostEncode with any type of body
func NewPostEncodeRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/encode")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteEncodeEncodeIdRequest generates requests for DeleteEncodeEncodeId
func NewDeleteEncodeEncodeIdRequest(server string, encodeId PathEncodeId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "encodeId", runtime.ParamLocationPath, encodeId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/encode/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetIptvChannelM3u8Request generates requests for GetIptvChannelM3u8
func NewGetIptvChannelM3u8Request(server string, params *GetIptvChannelM3u8Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iptv/channel.m3u8")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IsHalfWidth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isHalfWidth", runtime.ParamLocationQuery, *params.IsHalfWidth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "mode", runtime.ParamLocationQuery, params.Mode); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetIptvEpgXmlRequest generates requests for GetIptvEpgXml
func NewGetIptvEpgXmlRequest(server string, params *GetIptvEpgXmlParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/iptv/epg.xml")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IsHalfWidth != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isHalfWidth", runtime.ParamLocationQuery, *params.IsHalfWidth); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Days != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "days", runtime.ParamLocationQuery, *params.Days); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRecordedRequest generates requests for GetRecorded
func NewGetRecordedRequest(server string, params *GetRecordedParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/recorded")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isHalfWidth", runtime.ParamLocationQuery, params.IsHalfWidth); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsReverse != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isReverse", runtime.ParamLocationQuery, *params.IsReverse); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RuleId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ruleId", runtime.ParamLocationQuery, *params.RuleId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ChannelId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "channelId", runtime.ParamLocationQuery, *params.ChannelId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Genre != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "genre", runtime.ParamLocationQuery, *params.Genre); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Keyword != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "keyword", runtime.ParamLocationQuery, *params.Keyword); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.HasOriginalFile != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "hasOriginalFile", runtime.ParamLocationQuery, *params.HasOriginalFile); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostRecordedRequest calls the generic PostRecorded builder with application/json body
func NewPostRecordedRequest(server string, body PostRecordedJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostRecordedRequestWithBody(server, "application/json", bodyReader)
}

// NewPostRecordedRequestWithBody generates requests for PostRecorded with any type of body
func NewPostRecordedRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/recorded")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostRecordedCleanupRequest generates requests for PostRecordedCleanup
func NewPostRecordedCleanupRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/recorded/cleanup")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRecordedOptionsRequest generates requests for GetRecordedOptions
func NewGetRecordedOptionsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/recorded/options")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteRecordedRecordedIdRequest generates requests for DeleteRecordedRecordedId
func NewDeleteRecordedRecordedIdRequest(server string, recordedId PathRecordedId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "recordedId", runtime.ParamLocationPath, recordedId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/recorded/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRecordedRecordedIdRequest generates requests for GetRecordedRecordedId
func NewGetRecordedRecordedIdRequest(server string, recordedId PathRecordedId, params *GetRecordedRecordedIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "recordedId", runtime.ParamLocationPath, recordedId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/recorded/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isHalfWidth", runtime.ParamLocationQuery, params.IsHalfWidth); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteRecordedRecordedIdEncodeRequest generates requests for DeleteRecordedRecordedIdEncode
func NewDeleteRecordedRecordedIdEncodeRequest(server string, recordedId PathRecordedId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "recordedId", runtime.ParamLocationPath, recordedId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/recorded/%s/encode", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPutRecordedRecordedIdProtectRequest generates requests for PutRecordedRecordedIdProtect
func NewPutRecordedRecordedIdProtectRequest(server string, recordedId PathRecordedId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "recordedId", runtime.ParamLocationPath, recordedId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/recorded/%s/protect", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPutRecordedRecordedIdUnprotectRequest generates requests for PutRecordedRecordedIdUnprotect
func NewPutRecordedRecordedIdUnprotectRequest(server string, recordedId PathRecordedId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "recordedId", runtime.ParamLocationPath, recordedId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/recorded/%s/unprotect", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRecordingRequest generates requests for GetRecording
func NewGetRecordingRequest(server string, params *GetRecordingParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/recording")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isHalfWidth", runtime.ParamLocationQuery, params.IsHalfWidth); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostRecordingResettimerRequest generates requests for PostRecordingResettimer
func NewPostRecordingResettimerRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/recording/resettimer")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetReservesRequest generates requests for GetReserves
func NewGetReservesRequest(server string, params *GetReservesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/reserves")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isHalfWidth", runtime.ParamLocationQuery, params.IsHalfWidth); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.RuleId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ruleId", runtime.ParamLocationQuery, *params.RuleId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostReservesRequest calls the generic PostReserves builder with application/json body
func NewPostReservesRequest(server string, body PostReservesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostReservesRequestWithBody(server, "application/json", bodyReader)
}

// NewPostReservesRequestWithBody generates requests for PostReserves with any type of body
func NewPostReservesRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/reserves")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetReservesCntsRequest generates requests for GetReservesCnts
func NewGetReservesCntsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/reserves/cnts")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetReservesListsRequest generates requests for GetReservesLists
func NewGetReservesListsRequest(server string, params *GetReservesListsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/reserves/lists")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "startAt", runtime.ParamLocationQuery, params.StartAt); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "endAt", runtime.ParamLocationQuery, params.EndAt); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostReservesUpdateRequest generates requests for PostReservesUpdate
func NewPostReservesUpdateRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/reserves/update")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteReservesReserveIdRequest generates requests for DeleteReservesReserveId
func NewDeleteReservesReserveIdRequest(server string, reserveId PathReserveId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "reserveId", runtime.ParamLocationPath, reserveId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/reserves/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetReservesReserveIdRequest generates requests for GetReservesReserveId
func NewGetReservesReserveIdRequest(server string, reserveId PathReserveId, params *GetReservesReserveIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "reserveId", runtime.ParamLocationPath, reserveId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/reserves/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isHalfWidth", runtime.ParamLocationQuery, params.IsHalfWidth); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPutReservesReserveIdRequest calls the generic PutReservesReserveId builder with application/json body
func NewPutReservesReserveIdRequest(server string, reserveId PathReserveId, body PutReservesReserveIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPutReservesReserveIdRequestWithBody(server, reserveId, "application/json", bodyReader)
}

// NewPutReservesReserveIdRequestWithBody generates requests for PutReservesReserveId with any type of body
func NewPutReservesReserveIdRequestWithBody(server string, reserveId PathReserveId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "reserveId", runtime.ParamLocationPath, reserveId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/reserves/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteReservesReserveIdOverlapRequest generates requests for DeleteReservesReserveIdOverlap
func NewDeleteReservesReserveIdOverlapRequest(server string, reserveId PathReserveId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "reserveId", runtime.ParamLocationPath, reserveId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/reserves/%s/overlap", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteReservesReserveIdSkipRequest generates requests for DeleteReservesReserveIdSkip
func NewDeleteReservesReserveIdSkipRequest(server string, reserveId PathReserveId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "reserveId", runtime.ParamLocationPath, reserveId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/reserves/%s/skip", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRulesRequest generates requests for GetRules
func NewGetRulesRequest(server string, params *GetRulesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rules")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Keyword != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "keyword", runtime.ParamLocationQuery, *params.Keyword); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostRulesRequest calls the generic PostRules builder with application/json body
func NewPostRulesRequest(server string, body PostRulesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostRulesRequestWithBody(server, "application/json", bodyReader)
}

// NewPostRulesRequestWithBody generates requests for PostRules with any type of body
func NewPostRulesRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rules")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetRulesKeywordRequest generates requests for GetRulesKeyword
func NewGetRulesKeywordRequest(server string, params *GetRulesKeywordParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rules/keyword")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Keyword != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "keyword", runtime.ParamLocationQuery, *params.Keyword); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostRulesKeywordRequest calls the generic PostRulesKeyword builder with application/json body
func NewPostRulesKeywordRequest(server string, body PostRulesKeywordJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostRulesKeywordRequestWithBody(server, "application/json", bodyReader)
}

// NewPostRulesKeywordRequestWithBody generates requests for PostRulesKeyword with any type of body
func NewPostRulesKeywordRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rules/keyword")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteRulesRuleIdRequest generates requests for DeleteRulesRuleId
func NewDeleteRulesRuleIdRequest(server string, ruleId PathRuleId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ruleId", runtime.ParamLocationPath, ruleId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rules/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRulesRuleIdRequest generates requests for GetRulesRuleId
func NewGetRulesRuleIdRequest(server string, ruleId PathRuleId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ruleId", runtime.ParamLocationPath, ruleId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rules/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPutRulesRuleIdRequest calls the generic PutRulesRuleId builder with application/json body
func NewPutRulesRuleIdRequest(server string, ruleId PathRuleId, body PutRulesRuleIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPutRulesRuleIdRequestWithBody(server, ruleId, "application/json", bodyReader)
}

// NewPutRulesRuleIdRequestWithBody generates requests for PutRulesRuleId with any type of body
func NewPutRulesRuleIdRequestWithBody(server string, ruleId PathRuleId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ruleId", runtime.ParamLocationPath, ruleId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rules/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPutRulesRuleIdDisableRequest generates requests for PutRulesRuleIdDisable
func NewPutRulesRuleIdDisableRequest(server string, ruleId PathRuleId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ruleId", runtime.ParamLocationPath, ruleId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rules/%s/disable", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPutRulesRuleIdEnableRequest generates requests for PutRulesRuleIdEnable
func NewPutRulesRuleIdEnableRequest(server string, ruleId PathRuleId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ruleId", runtime.ParamLocationPath, ruleId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rules/%s/enable", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSchedulesRequest generates requests for GetSchedules
func NewGetSchedulesRequest(server string, params *GetSchedulesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/schedules")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "startAt", runtime.ParamLocationQuery, params.StartAt); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "endAt", runtime.ParamLocationQuery, params.EndAt); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isHalfWidth", runtime.ParamLocationQuery, params.IsHalfWidth); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.NeedsRawExtended != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "needsRawExtended", runtime.ParamLocationQuery, *params.NeedsRawExtended); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsFree != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isFree", runtime.ParamLocationQuery, *params.IsFree); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "GR", runtime.ParamLocationQuery, params.GR); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "BS", runtime.ParamLocationQuery, params.BS); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "CS", runtime.ParamLocationQuery, params.CS); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "SKY", runtime.ParamLocationQuery, params.SKY); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSchedulesBroadcastingRequest generates requests for GetSchedulesBroadcasting
func NewGetSchedulesBroadcastingRequest(server string, params *GetSchedulesBroadcastingParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/schedules/broadcasting")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Time != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "time", runtime.ParamLocationQuery, *params.Time); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isHalfWidth", runtime.ParamLocationQuery, params.IsHalfWidth); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSchedulesDetailProgramIdRequest generates requests for GetSchedulesDetailProgramId
func NewGetSchedulesDetailProgramIdRequest(server string, programId PathProgramId, params *GetSchedulesDetailProgramIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "programId", runtime.ParamLocationPath, programId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/schedules/detail/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isHalfWidth", runtime.ParamLocationQuery, params.IsHalfWidth); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostSchedulesSearchRequest calls the generic PostSchedulesSearch builder with application/json body
func NewPostSchedulesSearchRequest(server string, body PostSchedulesSearchJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostSchedulesSearchRequestWithBody(server, "application/json", bodyReader)
}

// NewPostSchedulesSearchRequestWithBody generates requests for PostSchedulesSearch with any type of body
func NewPostSchedulesSearchRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/schedules/search")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetSchedulesChannelIdRequest generates requests for GetSchedulesChannelId
func NewGetSchedulesChannelIdRequest(server string, channelId PathChannelId, params *GetSchedulesChannelIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "channelId", runtime.ParamLocationPath, channelId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/schedules/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "startAt", runtime.ParamLocationQuery, params.StartAt); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "days", runtime.ParamLocationQuery, params.Days); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isHalfWidth", runtime.ParamLocationQuery, params.IsHalfWidth); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.NeedsRawExtended != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "needsRawExtended", runtime.ParamLocationQuery, *params.NeedsRawExtended); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsFree != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isFree", runtime.ParamLocationQuery, *params.IsFree); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetStoragesRequest generates requests for GetStorages
func NewGetStoragesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/storages")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteStreamsRequest generates requests for DeleteStreams
func NewDeleteStreamsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/streams")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetStreamsRequest generates requests for GetStreams
func NewGetStreamsRequest(server string, params *GetStreamsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/streams")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isHalfWidth", runtime.ParamLocationQuery, params.IsHalfWidth); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetStreamsLiveChannelIdHlsRequest generates requests for GetStreamsLiveChannelIdHls
func NewGetStreamsLiveChannelIdHlsRequest(server string, channelId PathChannelId, params *GetStreamsLiveChannelIdHlsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "channelId", runtime.ParamLocationPath, channelId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/streams/live/%s/hls", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "mode", runtime.ParamLocationQuery, params.Mode); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetStreamsLiveChannelIdM2tsRequest generates requests for GetStreamsLiveChannelIdM2ts
func NewGetStreamsLiveChannelIdM2tsRequest(server string, channelId PathChannelId, params *GetStreamsLiveChannelIdM2tsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "channelId", runtime.ParamLocationPath, channelId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/streams/live/%s/m2ts", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "mode", runtime.ParamLocationQuery, params.Mode); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetStreamsLiveChannelIdM2tsPlaylistRequest generates requests for GetStreamsLiveChannelIdM2tsPlaylist
func NewGetStreamsLiveChannelIdM2tsPlaylistRequest(server string, channelId PathChannelId, params *GetStreamsLiveChannelIdM2tsPlaylistParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "channelId", runtime.ParamLocationPath, channelId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/streams/live/%s/m2ts/playlist", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "mode", runtime.ParamLocationQuery, params.Mode); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetStreamsLiveChannelIdM2tsllRequest generates requests for GetStreamsLiveChannelIdM2tsll
func NewGetStreamsLiveChannelIdM2tsllRequest(server string, channelId PathChannelId, params *GetStreamsLiveChannelIdM2tsllParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "channelId", runtime.ParamLocationPath, channelId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/streams/live/%s/m2tsll", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "mode", runtime.ParamLocationQuery, params.Mode); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetStreamsLiveChannelIdMp4Request generates requests for GetStreamsLiveChannelIdMp4
func NewGetStreamsLiveChannelIdMp4Request(server string, channelId PathChannelId, params *GetStreamsLiveChannelIdMp4Params) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "channelId", runtime.ParamLocationPath, channelId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/streams/live/%s/mp4", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "mode", runtime.ParamLocationQuery, params.Mode); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetStreamsLiveChannelIdWebmRequest generates requests for GetStreamsLiveChannelIdWebm
func NewGetStreamsLiveChannelIdWebmRequest(server string, channelId PathChannelId, params *GetStreamsLiveChannelIdWebmParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "channelId", runtime.ParamLocationPath, channelId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/streams/live/%s/webm", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "mode", runtime.ParamLocationQuery, params.Mode); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetStreamsRecordedVideoFileIdHlsRequest generates requests for GetStreamsRecordedVideoFileIdHls
func NewGetStreamsRecordedVideoFileIdHlsRequest(server string, videoFileId PathVideoFileId, params *GetStreamsRecordedVideoFileIdHlsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "videoFileId", runtime.ParamLocationPath, videoFileId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/streams/recorded/%s/hls", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ss", runtime.ParamLocationQuery, params.Ss); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "mode", runtime.ParamLocationQuery, params.Mode); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetStreamsRecordedVideoFileIdMp4Request generates requests for GetStreamsRecordedVideoFileIdMp4
func NewGetStreamsRecordedVideoFileIdMp4Request(server string, videoFileId PathVideoFileId, params *GetStreamsRecordedVideoFileIdMp4Params) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "videoFileId", runtime.ParamLocationPath, videoFileId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/streams/recorded/%s/mp4", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ss", runtime.ParamLocationQuery, params.Ss); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "mode", runtime.ParamLocationQuery, params.Mode); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetStreamsRecordedVideoFileIdWebmRequest generates requests for GetStreamsRecordedVideoFileIdWebm
func NewGetStreamsRecordedVideoFileIdWebmRequest(server string, videoFileId PathVideoFileId, params *GetStreamsRecordedVideoFileIdWebmParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "videoFileId", runtime.ParamLocationPath, videoFileId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/streams/recorded/%s/webm", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ss", runtime.ParamLocationQuery, params.Ss); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "mode", runtime.ParamLocationQuery, params.Mode); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteStreamsStreamIdRequest generates requests for DeleteStreamsStreamId
func NewDeleteStreamsStreamIdRequest(server string, streamId PathStreamId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "streamId", runtime.ParamLocationPath, streamId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/streams/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPutStreamsStreamIdKeepRequest generates requests for PutStreamsStreamIdKeep
func NewPutStreamsStreamIdKeepRequest(server string, streamId PathStreamId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "streamId", runtime.ParamLocationPath, streamId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/streams/%s/keep", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTagsRequest generates requests for GetTags
func NewGetTagsRequest(server string, params *GetTagsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tags")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExcludeTagId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "excludeTagId", runtime.ParamLocationQuery, *params.ExcludeTagId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostTagsRequest calls the generic PostTags builder with application/json body
func NewPostTagsRequest(server string, body PostTagsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostTagsRequestWithBody(server, "application/json", bodyReader)
}

// NewPostTagsRequestWithBody generates requests for PostTags with any type of body
func NewPostTagsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tags")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteTagsTagIdRequest generates requests for DeleteTagsTagId
func NewDeleteTagsTagIdRequest(server string, tagId PathRecordedTagId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tagId", runtime.ParamLocationPath, tagId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tags/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPutTagsTagIdRequest calls the generic PutTagsTagId builder with application/json body
func NewPutTagsTagIdRequest(server string, tagId PathRecordedTagId, body PutTagsTagIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPutTagsTagIdRequestWithBody(server, tagId, "application/json", bodyReader)
}

// NewPutTagsTagIdRequestWithBody generates requests for PutTagsTagId with any type of body
func NewPutTagsTagIdRequestWithBody(server string, tagId PathRecordedTagId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tagId", runtime.ParamLocationPath, tagId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tags/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteTagsTagIdRelateRequest generates requests for DeleteTagsTagIdRelate
func NewDeleteTagsTagIdRelateRequest(server string, tagId PathRecordedTagId, params *DeleteTagsTagIdRelateParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tagId", runtime.ParamLocationPath, tagId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tags/%s/relate", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.RecordedId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "recordedId", runtime.ParamLocationQuery, *params.RecordedId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPutTagsTagIdRelateRequest calls the generic PutTagsTagIdRelate builder with application/json body
func NewPutTagsTagIdRelateRequest(server string, tagId PathRecordedTagId, body PutTagsTagIdRelateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPutTagsTagIdRelateRequestWithBody(server, tagId, "application/json", bodyReader)
}

// NewPutTagsTagIdRelateRequestWithBody generates requests for PutTagsTagIdRelate with any type of body
func NewPutTagsTagIdRelateRequestWithBody(server string, tagId PathRecordedTagId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tagId", runtime.ParamLocationPath, tagId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tags/%s/relate", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostThumbnailsRequest generates requests for PostThumbnails
func NewPostThumbnailsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/thumbnails")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostThumbnailsCleanupRequest generates requests for PostThumbnailsCleanup
func NewPostThumbnailsCleanupRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/thumbnails/cleanup")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetThumbnailsThumbnailIdRequest generates requests for GetThumbnailsThumbnailId
func NewGetThumbnailsThumbnailIdRequest(server string, thumbnailId PathThumbnailId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "thumbnailId", runtime.ParamLocationPath, thumbnailId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/thumbnails/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetVersionRequest generates requests for GetVersion
func NewGetVersionRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/version")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostVideosUploadRequestWithBody generates requests for PostVideosUpload with any type of body
func NewPostVideosUploadRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/videos/upload")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteVideosVideoFileIdRequest generates requests for DeleteVideosVideoFileId
func NewDeleteVideosVideoFileIdRequest(server string, videoFileId PathVideoFileId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "videoFileId", runtime.ParamLocationPath, videoFileId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/videos/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetVideosVideoFileIdRequest generates requests for GetVideosVideoFileId
func NewGetVideosVideoFileIdRequest(server string, videoFileId PathVideoFileId, params *GetVideosVideoFileIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "videoFileId", runtime.ParamLocationPath, videoFileId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/videos/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IsDownload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isDownload", runtime.ParamLocationQuery, *params.IsDownload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetVideosVideoFileIdDurationRequest generates requests for GetVideosVideoFileIdDuration
func NewGetVideosVideoFileIdDurationRequest(server string, videoFileId PathVideoFileId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "videoFileId", runtime.ParamLocationPath, videoFileId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/videos/%s/duration", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostVideosVideoFileIdKodiRequest calls the generic PostVideosVideoFileIdKodi builder with application/json body
func NewPostVideosVideoFileIdKodiRequest(server string, videoFileId PathVideoFileId, body PostVideosVideoFileIdKodiJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostVideosVideoFileIdKodiRequestWithBody(server, videoFileId, "application/json", bodyReader)
}

// NewPostVideosVideoFileIdKodiRequestWithBody generates requests for PostVideosVideoFileIdKodi with any type of body
func NewPostVideosVideoFileIdKodiRequestWithBody(server string, videoFileId PathVideoFileId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "videoFileId", runtime.ParamLocationPath, videoFileId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/videos/%s/kodi", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetVideosVideoFileIdPlaylistRequest generates requests for GetVideosVideoFileIdPlaylist
func NewGetVideosVideoFileIdPlaylistRequest(server string, videoFileId PathVideoFileId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "videoFileId", runtime.ParamLocationPath, videoFileId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/videos/%s/playlist", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetChannelsWithResponse request
	GetChannelsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetChannelsResponse, error)

	// GetChannelsChannelIdLogoWithResponse request
	GetChannelsChannelIdLogoWithResponse(ctx context.Context, channelId PathChannelId, reqEditors ...RequestEditorFn) (*GetChannelsChannelIdLogoResponse, error)

	// GetConfigWithResponse request
	GetConfigWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetConfigResponse, error)

	// GetDropLogsDropLogFileIdWithResponse request
	GetDropLogsDropLogFileIdWithResponse(ctx context.Context, dropLogFileId PathDropLogFileId, params *GetDropLogsDropLogFileIdParams, reqEditors ...RequestEditorFn) (*GetDropLogsDropLogFileIdResponse, error)

	// GetEncodeWithResponse request
	GetEncodeWithResponse(ctx context.Context, params *GetEncodeParams, reqEditors ...RequestEditorFn) (*GetEncodeResponse, error)

	// PostEncodeWithBodyWithResponse request with any body
	PostEncodeWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostEncodeResponse, error)

	PostEncodeWithResponse(ctx context.Context, body PostEncodeJSONRequestBody, reqEditors ...RequestEditorFn) (*PostEncodeResponse, error)

	// DeleteEncodeEncodeIdWithResponse request
	DeleteEncodeEncodeIdWithResponse(ctx context.Context, encodeId PathEncodeId, reqEditors ...RequestEditorFn) (*DeleteEncodeEncodeIdResponse, error)

	// GetIptvChannelM3u8WithResponse request
	GetIptvChannelM3u8WithResponse(ctx context.Context, params *GetIptvChannelM3u8Params, reqEditors ...RequestEditorFn) (*GetIptvChannelM3u8Response, error)

	// GetIptvEpgXmlWithResponse request
	GetIptvEpgXmlWithResponse(ctx context.Context, params *GetIptvEpgXmlParams, reqEditors ...RequestEditorFn) (*GetIptvEpgXmlResponse, error)

	// GetRecordedWithResponse request
	GetRecordedWithResponse(ctx context.Context, params *GetRecordedParams, reqEditors ...RequestEditorFn) (*GetRecordedResponse, error)

	// PostRecordedWithBodyWithResponse request with any body
	PostRecordedWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostRecordedResponse, error)

	PostRecordedWithResponse(ctx context.Context, body PostRecordedJSONRequestBody, reqEditors ...RequestEditorFn) (*PostRecordedResponse, error)

	// PostRecordedCleanupWithResponse request
	PostRecordedCleanupWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*PostRecordedCleanupResponse, error)

	// GetRecordedOptionsWithResponse request
	GetRecordedOptionsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetRecordedOptionsResponse, error)

	// DeleteRecordedRecordedIdWithResponse request
	DeleteRecordedRecordedIdWithResponse(ctx context.Context, recordedId PathRecordedId, reqEditors ...RequestEditorFn) (*DeleteRecordedRecordedIdResponse, error)

	// GetRecordedRecordedIdWithResponse request
	GetRecordedRecordedIdWithResponse(ctx context.Context, recordedId PathRecordedId, params *GetRecordedRecordedIdParams, reqEditors ...RequestEditorFn) (*GetRecordedRecordedIdResponse, error)

	// DeleteRecordedRecordedIdEncodeWithResponse request
	DeleteRecordedRecordedIdEncodeWithResponse(ctx context.Context, recordedId PathRecordedId, reqEditors ...RequestEditorFn) (*DeleteRecordedRecordedIdEncodeResponse, error)

	// PutRecordedRecordedIdProtectWithResponse request
	PutRecordedRecordedIdProtectWithResponse(ctx context.Context, recordedId PathRecordedId, reqEditors ...RequestEditorFn) (*PutRecordedRecordedIdProtectResponse, error)

	// PutRecordedRecordedIdUnprotectWithResponse request
	PutRecordedRecordedIdUnprotectWithResponse(ctx context.Context, recordedId PathRecordedId, reqEditors ...RequestEditorFn) (*PutRecordedRecordedIdUnprotectResponse, error)

	// GetRecordingWithResponse request
	GetRecordingWithResponse(ctx context.Context, params *GetRecordingParams, reqEditors ...RequestEditorFn) (*GetRecordingResponse, error)

	// PostRecordingResettimerWithResponse request
	PostRecordingResettimerWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*PostRecordingResettimerResponse, error)

	// GetReservesWithResponse request
	GetReservesWithResponse(ctx context.Context, params *GetReservesParams, reqEditors ...RequestEditorFn) (*GetReservesResponse, error)

	// PostReservesWithBodyWithResponse request with any body
	PostReservesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostReservesResponse, error)

	PostReservesWithResponse(ctx context.Context, body PostReservesJSONRequestBody, reqEditors ...RequestEditorFn) (*PostReservesResponse, error)

	// GetReservesCntsWithResponse request
	GetReservesCntsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetReservesCntsResponse, error)

	// GetReservesListsWithResponse request
	GetReservesListsWithResponse(ctx context.Context, params *GetReservesListsParams, reqEditors ...RequestEditorFn) (*GetReservesListsResponse, error)

	// PostReservesUpdateWithResponse request
	PostReservesUpdateWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*PostReservesUpdateResponse, error)

	// DeleteReservesReserveIdWithResponse request
	DeleteReservesReserveIdWithResponse(ctx context.Context, reserveId PathReserveId, reqEditors ...RequestEditorFn) (*DeleteReservesReserveIdResponse, error)

	// GetReservesReserveIdWithResponse request
	GetReservesReserveIdWithResponse(ctx context.Context, reserveId PathReserveId, params *GetReservesReserveIdParams, reqEditors ...RequestEditorFn) (*GetReservesReserveIdResponse, error)

	// PutReservesReserveIdWithBodyWithResponse request with any body
	PutReservesReserveIdWithBodyWithResponse(ctx context.Context, reserveId PathReserveId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutReservesReserveIdResponse, error)

	PutReservesReserveIdWithResponse(ctx context.Context, reserveId PathReserveId, body PutReservesReserveIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PutReservesReserveIdResponse, error)

	// DeleteReservesReserveIdOverlapWithResponse request
	DeleteReservesReserveIdOverlapWithResponse(ctx context.Context, reserveId PathReserveId, reqEditors ...RequestEditorFn) (*DeleteReservesReserveIdOverlapResponse, error)

	// DeleteReservesReserveIdSkipWithResponse request
	DeleteReservesReserveIdSkipWithResponse(ctx context.Context, reserveId PathReserveId, reqEditors ...RequestEditorFn) (*DeleteReservesReserveIdSkipResponse, error)

	// GetRulesWithResponse request
	GetRulesWithResponse(ctx context.Context, params *GetRulesParams, reqEditors ...RequestEditorFn) (*GetRulesResponse, error)

	// PostRulesWithBodyWithResponse request with any body
	PostRulesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostRulesResponse, error)

	PostRulesWithResponse(ctx context.Context, body PostRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*PostRulesResponse, error)

	// GetRulesKeywordWithResponse request
	GetRulesKeywordWithResponse(ctx context.Context, params *GetRulesKeywordParams, reqEditors ...RequestEditorFn) (*GetRulesKeywordResponse, error)

	// PostRulesKeywordWithBodyWithResponse request with any body
	PostRulesKeywordWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostRulesKeywordResponse, error)

	PostRulesKeywordWithResponse(ctx context.Context, body PostRulesKeywordJSONRequestBody, reqEditors ...RequestEditorFn) (*PostRulesKeywordResponse, error)

	// DeleteRulesRuleIdWithResponse request
	DeleteRulesRuleIdWithResponse(ctx context.Context, ruleId PathRuleId, reqEditors ...RequestEditorFn) (*DeleteRulesRuleIdResponse, error)

	// GetRulesRuleIdWithResponse request
	GetRulesRuleIdWithResponse(ctx context.Context, ruleId PathRuleId, reqEditors ...RequestEditorFn) (*GetRulesRuleIdResponse, error)

	// PutRulesRuleIdWithBodyWithResponse request with any body
	PutRulesRuleIdWithBodyWithResponse(ctx context.Context, ruleId PathRuleId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutRulesRuleIdResponse, error)

	PutRulesRuleIdWithResponse(ctx context.Context, ruleId PathRuleId, body PutRulesRuleIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PutRulesRuleIdResponse, error)

	// PutRulesRuleIdDisableWithResponse request
	PutRulesRuleIdDisableWithResponse(ctx context.Context, ruleId PathRuleId, reqEditors ...RequestEditorFn) (*PutRulesRuleIdDisableResponse, error)

	// PutRulesRuleIdEnableWithResponse request
	PutRulesRuleIdEnableWithResponse(ctx context.Context, ruleId PathRuleId, reqEditors ...RequestEditorFn) (*PutRulesRuleIdEnableResponse, error)

	// GetSchedulesWithResponse request
	GetSchedulesWithResponse(ctx context.Context, params *GetSchedulesParams, reqEditors ...RequestEditorFn) (*GetSchedulesResponse, error)

	// GetSchedulesBroadcastingWithResponse request
	GetSchedulesBroadcastingWithResponse(ctx context.Context, params *GetSchedulesBroadcastingParams, reqEditors ...RequestEditorFn) (*GetSchedulesBroadcastingResponse, error)

	// GetSchedulesDetailProgramIdWithResponse request
	GetSchedulesDetailProgramIdWithResponse(ctx context.Context, programId PathProgramId, params *GetSchedulesDetailProgramIdParams, reqEditors ...RequestEditorFn) (*GetSchedulesDetailProgramIdResponse, error)

	// PostSchedulesSearchWithBodyWithResponse request with any body
	PostSchedulesSearchWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSchedulesSearchResponse, error)

	PostSchedulesSearchWithResponse(ctx context.Context, body PostSchedulesSearchJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSchedulesSearchResponse, error)

	// GetSchedulesChannelIdWithResponse request
	GetSchedulesChannelIdWithResponse(ctx context.Context, channelId PathChannelId, params *GetSchedulesChannelIdParams, reqEditors ...RequestEditorFn) (*GetSchedulesChannelIdResponse, error)

	// GetStoragesWithResponse request
	GetStoragesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetStoragesResponse, error)

	// DeleteStreamsWithResponse request
	DeleteStreamsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*DeleteStreamsResponse, error)

	// GetStreamsWithResponse request
	GetStreamsWithResponse(ctx context.Context, params *GetStreamsParams, reqEditors ...RequestEditorFn) (*GetStreamsResponse, error)

	// GetStreamsLiveChannelIdHlsWithResponse request
	GetStreamsLiveChannelIdHlsWithResponse(ctx context.Context, channelId PathChannelId, params *GetStreamsLiveChannelIdHlsParams, reqEditors ...RequestEditorFn) (*GetStreamsLiveChannelIdHlsResponse, error)

	// GetStreamsLiveChannelIdM2tsWithResponse request
	GetStreamsLiveChannelIdM2tsWithResponse(ctx context.Context, channelId PathChannelId, params *GetStreamsLiveChannelIdM2tsParams, reqEditors ...RequestEditorFn) (*GetStreamsLiveChannelIdM2tsResponse, error)

	// GetStreamsLiveChannelIdM2tsPlaylistWithResponse request
	GetStreamsLiveChannelIdM2tsPlaylistWithResponse(ctx context.Context, channelId PathChannelId, params *GetStreamsLiveChannelIdM2tsPlaylistParams, reqEditors ...RequestEditorFn) (*GetStreamsLiveChannelIdM2tsPlaylistResponse, error)

	// GetStreamsLiveChannelIdM2tsllWithResponse request
	GetStreamsLiveChannelIdM2tsllWithResponse(ctx context.Context, channelId PathChannelId, params *GetStreamsLiveChannelIdM2tsllParams, reqEditors ...RequestEditorFn) (*GetStreamsLiveChannelIdM2tsllResponse, error)

	// GetStreamsLiveChannelIdMp4WithResponse request
	GetStreamsLiveChannelIdMp4WithResponse(ctx context.Context, channelId PathChannelId, params *GetStreamsLiveChannelIdMp4Params, reqEditors ...RequestEditorFn) (*GetStreamsLiveChannelIdMp4Response, error)

	// GetStreamsLiveChannelIdWebmWithResponse request
	GetStreamsLiveChannelIdWebmWithResponse(ctx context.Context, channelId PathChannelId, params *GetStreamsLiveChannelIdWebmParams, reqEditors ...RequestEditorFn) (*GetStreamsLiveChannelIdWebmResponse, error)

	// GetStreamsRecordedVideoFileIdHlsWithResponse request
	GetStreamsRecordedVideoFileIdHlsWithResponse(ctx context.Context, videoFileId PathVideoFileId, params *GetStreamsRecordedVideoFileIdHlsParams, reqEditors ...RequestEditorFn) (*GetStreamsRecordedVideoFileIdHlsResponse, error)

	// GetStreamsRecordedVideoFileIdMp4WithResponse request
	GetStreamsRecordedVideoFileIdMp4WithResponse(ctx context.Context, videoFileId PathVideoFileId, params *GetStreamsRecordedVideoFileIdMp4Params, reqEditors ...RequestEditorFn) (*GetStreamsRecordedVideoFileIdMp4Response, error)

	// GetStreamsRecordedVideoFileIdWebmWithResponse request
	GetStreamsRecordedVideoFileIdWebmWithResponse(ctx context.Context, videoFileId PathVideoFileId, params *GetStreamsRecordedVideoFileIdWebmParams, reqEditors ...RequestEditorFn) (*GetStreamsRecordedVideoFileIdWebmResponse, error)

	// DeleteStreamsStreamIdWithResponse request
	DeleteStreamsStreamIdWithResponse(ctx context.Context, streamId PathStreamId, reqEditors ...RequestEditorFn) (*DeleteStreamsStreamIdResponse, error)

	// PutStreamsStreamIdKeepWithResponse request
	PutStreamsStreamIdKeepWithResponse(ctx context.Context, streamId PathStreamId, reqEditors ...RequestEditorFn) (*PutStreamsStreamIdKeepResponse, error)

	// GetTagsWithResponse request
	GetTagsWithResponse(ctx context.Context, params *GetTagsParams, reqEditors ...RequestEditorFn) (*GetTagsResponse, error)

	// PostTagsWithBodyWithResponse request with any body
	PostTagsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostTagsResponse, error)

	PostTagsWithResponse(ctx context.Context, body PostTagsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostTagsResponse, error)

	// DeleteTagsTagIdWithResponse request
	DeleteTagsTagIdWithResponse(ctx context.Context, tagId PathRecordedTagId, reqEditors ...RequestEditorFn) (*DeleteTagsTagIdResponse, error)

	// PutTagsTagIdWithBodyWithResponse request with any body
	PutTagsTagIdWithBodyWithResponse(ctx context.Context, tagId PathRecordedTagId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutTagsTagIdResponse, error)

	PutTagsTagIdWithResponse(ctx context.Context, tagId PathRecordedTagId, body PutTagsTagIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PutTagsTagIdResponse, error)

	// DeleteTagsTagIdRelateWithResponse request
	DeleteTagsTagIdRelateWithResponse(ctx context.Context, tagId PathRecordedTagId, params *DeleteTagsTagIdRelateParams, reqEditors ...RequestEditorFn) (*DeleteTagsTagIdRelateResponse, error)

	// PutTagsTagIdRelateWithBodyWithResponse request with any body
	PutTagsTagIdRelateWithBodyWithResponse(ctx context.Context, tagId PathRecordedTagId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutTagsTagIdRelateResponse, error)

	PutTagsTagIdRelateWithResponse(ctx context.Context, tagId PathRecordedTagId, body PutTagsTagIdRelateJSONRequestBody, reqEditors ...RequestEditorFn) (*PutTagsTagIdRelateResponse, error)

	// PostThumbnailsWithResponse request
	PostThumbnailsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*PostThumbnailsResponse, error)

	// PostThumbnailsCleanupWithResponse request
	PostThumbnailsCleanupWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*PostThumbnailsCleanupResponse, error)

	// GetThumbnailsThumbnailIdWithResponse request
	GetThumbnailsThumbnailIdWithResponse(ctx context.Context, thumbnailId PathThumbnailId, reqEditors ...RequestEditorFn) (*GetThumbnailsThumbnailIdResponse, error)

	// GetVersionWithResponse request
	GetVersionWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetVersionResponse, error)

	// PostVideosUploadWithBodyWithResponse request with any body
	PostVideosUploadWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostVideosUploadResponse, error)

	// DeleteVideosVideoFileIdWithResponse request
	DeleteVideosVideoFileIdWithResponse(ctx context.Context, videoFileId PathVideoFileId, reqEditors ...RequestEditorFn) (*DeleteVideosVideoFileIdResponse, error)

	// GetVideosVideoFileIdWithResponse request
	GetVideosVideoFileIdWithResponse(ctx context.Context, videoFileId PathVideoFileId, params *GetVideosVideoFileIdParams, reqEditors ...RequestEditorFn) (*GetVideosVideoFileIdResponse, error)

	// GetVideosVideoFileIdDurationWithResponse request
	GetVideosVideoFileIdDurationWithResponse(ctx context.Context, videoFileId PathVideoFileId, reqEditors ...RequestEditorFn) (*GetVideosVideoFileIdDurationResponse, error)

	// PostVideosVideoFileIdKodiWithBodyWithResponse request with any body
	PostVideosVideoFileIdKodiWithBodyWithResponse(ctx context.Context, videoFileId PathVideoFileId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostVideosVideoFileIdKodiResponse, error)

	PostVideosVideoFileIdKodiWithResponse(ctx context.Context, videoFileId PathVideoFileId, body PostVideosVideoFileIdKodiJSONRequestBody, reqEditors ...RequestEditorFn) (*PostVideosVideoFileIdKodiResponse, error)

	// GetVideosVideoFileIdPlaylistWithResponse request
	GetVideosVideoFileIdPlaylistWithResponse(ctx context.Context, videoFileId PathVideoFileId, reqEditors ...RequestEditorFn) (*GetVideosVideoFileIdPlaylistResponse, error)
}

type GetChannelsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ChannelItems
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetChannelsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetChannelsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetChannelsChannelIdLogoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetChannelsChannelIdLogoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetChannelsChannelIdLogoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetConfigResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Config
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetConfigResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetConfigResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDropLogsDropLogFileIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetDropLogsDropLogFileIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDropLogsDropLogFileIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetEncodeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EncodeInfo
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetEncodeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetEncodeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostEncodeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *AddedEncode
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r PostEncodeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostEncodeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteEncodeEncodeIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r DeleteEncodeEncodeIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteEncodeEncodeIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetIptvChannelM3u8Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetIptvChannelM3u8Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetIptvChannelM3u8Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetIptvEpgXmlResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetIptvEpgXmlResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetIptvEpgXmlResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRecordedResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Records
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetRecordedResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRecordedResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostRecordedResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *CreatedNewRecorded
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r PostRecordedResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostRecordedResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostRecordedCleanupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r PostRecordedCleanupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostRecordedCleanupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRecordedOptionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RecordedSearchOptions
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetRecordedOptionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRecordedOptionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteRecordedRecordedIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r DeleteRecordedRecordedIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteRecordedRecordedIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRecordedRecordedIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RecordedItem
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetRecordedRecordedIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRecordedRecordedIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteRecordedRecordedIdEncodeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r DeleteRecordedRecordedIdEncodeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteRecordedRecordedIdEncodeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PutRecordedRecordedIdProtectResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r PutRecordedRecordedIdProtectResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PutRecordedRecordedIdProtectResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PutRecordedRecordedIdUnprotectResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r PutRecordedRecordedIdUnprotectResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PutRecordedRecordedIdUnprotectResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRecordingResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Records
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetRecordingResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRecordingResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostRecordingResettimerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r PostRecordingResettimerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostRecordingResettimerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetReservesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Reserves
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetReservesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetReservesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostReservesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *AddedReserve
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r PostReservesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostReservesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetReservesCntsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ReserveCnts
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetReservesCntsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetReservesCntsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetReservesListsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ReserveLists
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetReservesListsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetReservesListsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostReservesUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r PostReservesUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostReservesUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteReservesReserveIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r DeleteReservesReserveIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteReservesReserveIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetReservesReserveIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ReserveItem
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetReservesReserveIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetReservesReserveIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PutReservesReserveIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r PutReservesReserveIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PutReservesReserveIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteReservesReserveIdOverlapResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r DeleteReservesReserveIdOverlapResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteReservesReserveIdOverlapResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteReservesReserveIdSkipResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r DeleteReservesReserveIdSkipResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteReservesReserveIdSkipResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRulesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Rules
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetRulesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRulesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostRulesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *AddedRule
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r PostRulesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostRulesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRulesKeywordResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RuleKeywordInfo
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetRulesKeywordResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRulesKeywordResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostRulesKeywordResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *AddedRule
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r PostRulesKeywordResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostRulesKeywordResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteRulesRuleIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r DeleteRulesRuleIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteRulesRuleIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRulesRuleIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Rule
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetRulesRuleIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRulesRuleIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PutRulesRuleIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r PutRulesRuleIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PutRulesRuleIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PutRulesRuleIdDisableResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r PutRulesRuleIdDisableResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PutRulesRuleIdDisableResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PutRulesRuleIdEnableResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r PutRulesRuleIdEnableResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PutRulesRuleIdEnableResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSchedulesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Schedules
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetSchedulesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSchedulesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSchedulesBroadcastingResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Schedules
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetSchedulesBroadcastingResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSchedulesBroadcastingResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSchedulesDetailProgramIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ScheduleProgramItem
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetSchedulesDetailProgramIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSchedulesDetailProgramIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostSchedulesSearchResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]ScheduleProgramItem
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r PostSchedulesSearchResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostSchedulesSearchResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSchedulesChannelIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Schedules
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetSchedulesChannelIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSchedulesChannelIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetStoragesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StorageInfo
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetStoragesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStoragesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteStreamsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r DeleteStreamsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteStreamsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetStreamsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StreamInfo
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetStreamsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStreamsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetStreamsLiveChannelIdHlsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StartStreamInfo
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetStreamsLiveChannelIdHlsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStreamsLiveChannelIdHlsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetStreamsLiveChannelIdM2tsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetStreamsLiveChannelIdM2tsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStreamsLiveChannelIdM2tsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetStreamsLiveChannelIdM2tsPlaylistResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetStreamsLiveChannelIdM2tsPlaylistResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStreamsLiveChannelIdM2tsPlaylistResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetStreamsLiveChannelIdM2tsllResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetStreamsLiveChannelIdM2tsllResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStreamsLiveChannelIdM2tsllResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetStreamsLiveChannelIdMp4Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetStreamsLiveChannelIdMp4Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStreamsLiveChannelIdMp4Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetStreamsLiveChannelIdWebmResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetStreamsLiveChannelIdWebmResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStreamsLiveChannelIdWebmResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetStreamsRecordedVideoFileIdHlsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StartStreamInfo
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetStreamsRecordedVideoFileIdHlsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStreamsRecordedVideoFileIdHlsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetStreamsRecordedVideoFileIdMp4Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetStreamsRecordedVideoFileIdMp4Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStreamsRecordedVideoFileIdMp4Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetStreamsRecordedVideoFileIdWebmResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetStreamsRecordedVideoFileIdWebmResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStreamsRecordedVideoFileIdWebmResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteStreamsStreamIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r DeleteStreamsStreamIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteStreamsStreamIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PutStreamsStreamIdKeepResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r PutStreamsStreamIdKeepResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PutStreamsStreamIdKeepResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTagsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RecordedTags
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetTagsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTagsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostTagsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *AddedRecordedTag
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r PostTagsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostTagsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteTagsTagIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r DeleteTagsTagIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteTagsTagIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PutTagsTagIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r PutTagsTagIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PutTagsTagIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteTagsTagIdRelateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r DeleteTagsTagIdRelateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteTagsTagIdRelateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PutTagsTagIdRelateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r PutTagsTagIdRelateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PutTagsTagIdRelateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostThumbnailsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r PostThumbnailsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostThumbnailsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostThumbnailsCleanupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r PostThumbnailsCleanupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostThumbnailsCleanupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetThumbnailsThumbnailIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetThumbnailsThumbnailIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetThumbnailsThumbnailIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetVersionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Version
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetVersionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetVersionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostVideosUploadResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r PostVideosUploadResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostVideosUploadResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteVideosVideoFileIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r DeleteVideosVideoFileIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteVideosVideoFileIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetVideosVideoFileIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetVideosVideoFileIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetVideosVideoFileIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetVideosVideoFileIdDurationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VideoFileDuration
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetVideosVideoFileIdDurationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetVideosVideoFileIdDurationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostVideosVideoFileIdKodiResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r PostVideosVideoFileIdKodiResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostVideosVideoFileIdKodiResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetVideosVideoFileIdPlaylistResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetVideosVideoFileIdPlaylistResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetVideosVideoFileIdPlaylistResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetChannelsWithResponse request returning *GetChannelsResponse
func (c *ClientWithResponses) GetChannelsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetChannelsResponse, error) {
	rsp, err := c.GetChannels(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetChannelsResponse(rsp)
}

// GetChannelsChannelIdLogoWithResponse request returning *GetChannelsChannelIdLogoResponse
func (c *ClientWithResponses) GetChannelsChannelIdLogoWithResponse(ctx context.Context, channelId PathChannelId, reqEditors ...RequestEditorFn) (*GetChannelsChannelIdLogoResponse, error) {
	rsp, err := c.GetChannelsChannelIdLogo(ctx, channelId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetChannelsChannelIdLogoResponse(rsp)
}

// GetConfigWithResponse request returning *GetConfigResponse
func (c *ClientWithResponses) GetConfigWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetConfigResponse, error) {
	rsp, err := c.GetConfig(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetConfigResponse(rsp)
}

// GetDropLogsDropLogFileIdWithResponse request returning *GetDropLogsDropLogFileIdResponse
func (c *ClientWithResponses) GetDropLogsDropLogFileIdWithResponse(ctx context.Context, dropLogFileId PathDropLogFileId, params *GetDropLogsDropLogFileIdParams, reqEditors ...RequestEditorFn) (*GetDropLogsDropLogFileIdResponse, error) {
	rsp, err := c.GetDropLogsDropLogFileId(ctx, dropLogFileId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDropLogsDropLogFileIdResponse(rsp)
}

// GetEncodeWithResponse request returning *GetEncodeResponse
func (c *ClientWithResponses) GetEncodeWithResponse(ctx context.Context, params *GetEncodeParams, reqEditors ...RequestEditorFn) (*GetEncodeResponse, error) {
	rsp, err := c.GetEncode(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetEncodeResponse(rsp)
}

// PostEncodeWithBodyWithResponse request with arbitrary body returning *PostEncodeResponse
func (c *ClientWithResponses) PostEncodeWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostEncodeResponse, error) {
	rsp, err := c.PostEncodeWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostEncodeResponse(rsp)
}

func (c *ClientWithResponses) PostEncodeWithResponse(ctx context.Context, body PostEncodeJSONRequestBody, reqEditors ...RequestEditorFn) (*PostEncodeResponse, error) {
	rsp, err := c.PostEncode(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostEncodeResponse(rsp)
}

// DeleteEncodeEncodeIdWithResponse request returning *DeleteEncodeEncodeIdResponse
func (c *ClientWithResponses) DeleteEncodeEncodeIdWithResponse(ctx context.Context, encodeId PathEncodeId, reqEditors ...RequestEditorFn) (*DeleteEncodeEncodeIdResponse, error) {
	rsp, err := c.DeleteEncodeEncodeId(ctx, encodeId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteEncodeEncodeIdResponse(rsp)
}

// GetIptvChannelM3u8WithResponse request returning *GetIptvChannelM3u8Response
func (c *ClientWithResponses) GetIptvChannelM3u8WithResponse(ctx context.Context, params *GetIptvChannelM3u8Params, reqEditors ...RequestEditorFn) (*GetIptvChannelM3u8Response, error) {
	rsp, err := c.GetIptvChannelM3u8(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetIptvChannelM3u8Response(rsp)
}

// GetIptvEpgXmlWithResponse request returning *GetIptvEpgXmlResponse
func (c *ClientWithResponses) GetIptvEpgXmlWithResponse(ctx context.Context, params *GetIptvEpgXmlParams, reqEditors ...RequestEditorFn) (*GetIptvEpgXmlResponse, error) {
	rsp, err := c.GetIptvEpgXml(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetIptvEpgXmlResponse(rsp)
}

// GetRecordedWithResponse request returning *GetRecordedResponse
func (c *ClientWithResponses) GetRecordedWithResponse(ctx context.Context, params *GetRecordedParams, reqEditors ...RequestEditorFn) (*GetRecordedResponse, error) {
	rsp, err := c.GetRecorded(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRecordedResponse(rsp)
}

// PostRecordedWithBodyWithResponse request with arbitrary body returning *PostRecordedResponse
func (c *ClientWithResponses) PostRecordedWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostRecordedResponse, error) {
	rsp, err := c.PostRecordedWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostRecordedResponse(rsp)
}

func (c *ClientWithResponses) PostRecordedWithResponse(ctx context.Context, body PostRecordedJSONRequestBody, reqEditors ...RequestEditorFn) (*PostRecordedResponse, error) {
	rsp, err := c.PostRecorded(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostRecordedResponse(rsp)
}

// PostRecordedCleanupWithResponse request returning *PostRecordedCleanupResponse
func (c *ClientWithResponses) PostRecordedCleanupWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*PostRecordedCleanupResponse, error) {
	rsp, err := c.PostRecordedCleanup(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostRecordedCleanupResponse(rsp)
}

// GetRecordedOptionsWithResponse request returning *GetRecordedOptionsResponse
func (c *ClientWithResponses) GetRecordedOptionsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetRecordedOptionsResponse, error) {
	rsp, err := c.GetRecordedOptions(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRecordedOptionsResponse(rsp)
}

// DeleteRecordedRecordedIdWithResponse request returning *DeleteRecordedRecordedIdResponse
func (c *ClientWithResponses) DeleteRecordedRecordedIdWithResponse(ctx context.Context, recordedId PathRecordedId, reqEditors ...RequestEditorFn) (*DeleteRecordedRecordedIdResponse, error) {
	rsp, err := c.DeleteRecordedRecordedId(ctx, recordedId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteRecordedRecordedIdResponse(rsp)
}

// GetRecordedRecordedIdWithResponse request returning *GetRecordedRecordedIdResponse
func (c *ClientWithResponses) GetRecordedRecordedIdWithResponse(ctx context.Context, recordedId PathRecordedId, params *GetRecordedRecordedIdParams, reqEditors ...RequestEditorFn) (*GetRecordedRecordedIdResponse, error) {
	rsp, err := c.GetRecordedRecordedId(ctx, recordedId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRecordedRecordedIdResponse(rsp)
}

// DeleteRecordedRecordedIdEncodeWithResponse request returning *DeleteRecordedRecordedIdEncodeResponse
func (c *ClientWithResponses) DeleteRecordedRecordedIdEncodeWithResponse(ctx context.Context, recordedId PathRecordedId, reqEditors ...RequestEditorFn) (*DeleteRecordedRecordedIdEncodeResponse, error) {
	rsp, err := c.DeleteRecordedRecordedIdEncode(ctx, recordedId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteRecordedRecordedIdEncodeResponse(rsp)
}

// PutRecordedRecordedIdProtectWithResponse request returning *PutRecordedRecordedIdProtectResponse
func (c *ClientWithResponses) PutRecordedRecordedIdProtectWithResponse(ctx context.Context, recordedId PathRecordedId, reqEditors ...RequestEditorFn) (*PutRecordedRecordedIdProtectResponse, error) {
	rsp, err := c.PutRecordedRecordedIdProtect(ctx, recordedId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutRecordedRecordedIdProtectResponse(rsp)
}

// PutRecordedRecordedIdUnprotectWithResponse request returning *PutRecordedRecordedIdUnprotectResponse
func (c *ClientWithResponses) PutRecordedRecordedIdUnprotectWithResponse(ctx context.Context, recordedId PathRecordedId, reqEditors ...RequestEditorFn) (*PutRecordedRecordedIdUnprotectResponse, error) {
	rsp, err := c.PutRecordedRecordedIdUnprotect(ctx, recordedId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutRecordedRecordedIdUnprotectResponse(rsp)
}

// GetRecordingWithResponse request returning *GetRecordingResponse
func (c *ClientWithResponses) GetRecordingWithResponse(ctx context.Context, params *GetRecordingParams, reqEditors ...RequestEditorFn) (*GetRecordingResponse, error) {
	rsp, err := c.GetRecording(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRecordingResponse(rsp)
}

// PostRecordingResettimerWithResponse request returning *PostRecordingResettimerResponse
func (c *ClientWithResponses) PostRecordingResettimerWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*PostRecordingResettimerResponse, error) {
	rsp, err := c.PostRecordingResettimer(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostRecordingResettimerResponse(rsp)
}

// GetReservesWithResponse request returning *GetReservesResponse
func (c *ClientWithResponses) GetReservesWithResponse(ctx context.Context, params *GetReservesParams, reqEditors ...RequestEditorFn) (*GetReservesResponse, error) {
	rsp, err := c.GetReserves(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetReservesResponse(rsp)
}

// PostReservesWithBodyWithResponse request with arbitrary body returning *PostReservesResponse
func (c *ClientWithResponses) PostReservesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostReservesResponse, error) {
	rsp, err := c.PostReservesWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostReservesResponse(rsp)
}

func (c *ClientWithResponses) PostReservesWithResponse(ctx context.Context, body PostReservesJSONRequestBody, reqEditors ...RequestEditorFn) (*PostReservesResponse, error) {
	rsp, err := c.PostReserves(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostReservesResponse(rsp)
}

// GetReservesCntsWithResponse request returning *GetReservesCntsResponse
func (c *ClientWithResponses) GetReservesCntsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetReservesCntsResponse, error) {
	rsp, err := c.GetReservesCnts(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetReservesCntsResponse(rsp)
}

// GetReservesListsWithResponse request returning *GetReservesListsResponse
func (c *ClientWithResponses) GetReservesListsWithResponse(ctx context.Context, params *GetReservesListsParams, reqEditors ...RequestEditorFn) (*GetReservesListsResponse, error) {
	rsp, err := c.GetReservesLists(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetReservesListsResponse(rsp)
}

// PostReservesUpdateWithResponse request returning *PostReservesUpdateResponse
func (c *ClientWithResponses) PostReservesUpdateWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*PostReservesUpdateResponse, error) {
	rsp, err := c.PostReservesUpdate(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostReservesUpdateResponse(rsp)
}

// DeleteReservesReserveIdWithResponse request returning *DeleteReservesReserveIdResponse
func (c *ClientWithResponses) DeleteReservesReserveIdWithResponse(ctx context.Context, reserveId PathReserveId, reqEditors ...RequestEditorFn) (*DeleteReservesReserveIdResponse, error) {
	rsp, err := c.DeleteReservesReserveId(ctx, reserveId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteReservesReserveIdResponse(rsp)
}

// GetReservesReserveIdWithResponse request returning *GetReservesReserveIdResponse
func (c *ClientWithResponses) GetReservesReserveIdWithResponse(ctx context.Context, reserveId PathReserveId, params *GetReservesReserveIdParams, reqEditors ...RequestEditorFn) (*GetReservesReserveIdResponse, error) {
	rsp, err := c.GetReservesReserveId(ctx, reserveId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetReservesReserveIdResponse(rsp)
}

// PutReservesReserveIdWithBodyWithResponse request with arbitrary body returning *PutReservesReserveIdResponse
func (c *ClientWithResponses) PutReservesReserveIdWithBodyWithResponse(ctx context.Context, reserveId PathReserveId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutReservesReserveIdResponse, error) {
	rsp, err := c.PutReservesReserveIdWithBody(ctx, reserveId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutReservesReserveIdResponse(rsp)
}

func (c *ClientWithResponses) PutReservesReserveIdWithResponse(ctx context.Context, reserveId PathReserveId, body PutReservesReserveIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PutReservesReserveIdResponse, error) {
	rsp, err := c.PutReservesReserveId(ctx, reserveId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutReservesReserveIdResponse(rsp)
}

// DeleteReservesReserveIdOverlapWithResponse request returning *DeleteReservesReserveIdOverlapResponse
func (c *ClientWithResponses) DeleteReservesReserveIdOverlapWithResponse(ctx context.Context, reserveId PathReserveId, reqEditors ...RequestEditorFn) (*DeleteReservesReserveIdOverlapResponse, error) {
	rsp, err := c.DeleteReservesReserveIdOverlap(ctx, reserveId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteReservesReserveIdOverlapResponse(rsp)
}

// DeleteReservesReserveIdSkipWithResponse request returning *DeleteReservesReserveIdSkipResponse
func (c *ClientWithResponses) DeleteReservesReserveIdSkipWithResponse(ctx context.Context, reserveId PathReserveId, reqEditors ...RequestEditorFn) (*DeleteReservesReserveIdSkipResponse, error) {
	rsp, err := c.DeleteReservesReserveIdSkip(ctx, reserveId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteReservesReserveIdSkipResponse(rsp)
}

// GetRulesWithResponse request returning *GetRulesResponse
func (c *ClientWithResponses) GetRulesWithResponse(ctx context.Context, params *GetRulesParams, reqEditors ...RequestEditorFn) (*GetRulesResponse, error) {
	rsp, err := c.GetRules(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRulesResponse(rsp)
}

// PostRulesWithBodyWithResponse request with arbitrary body returning *PostRulesResponse
func (c *ClientWithResponses) PostRulesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostRulesResponse, error) {
	rsp, err := c.PostRulesWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostRulesResponse(rsp)
}

func (c *ClientWithResponses) PostRulesWithResponse(ctx context.Context, body PostRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*PostRulesResponse, error) {
	rsp, err := c.PostRules(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostRulesResponse(rsp)
}

// GetRulesKeywordWithResponse request returning *GetRulesKeywordResponse
func (c *ClientWithResponses) GetRulesKeywordWithResponse(ctx context.Context, params *GetRulesKeywordParams, reqEditors ...RequestEditorFn) (*GetRulesKeywordResponse, error) {
	rsp, err := c.GetRulesKeyword(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRulesKeywordResponse(rsp)
}

// PostRulesKeywordWithBodyWithResponse request with arbitrary body returning *PostRulesKeywordResponse
func (c *ClientWithResponses) PostRulesKeywordWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostRulesKeywordResponse, error) {
	rsp, err := c.PostRulesKeywordWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostRulesKeywordResponse(rsp)
}

func (c *ClientWithResponses) PostRulesKeywordWithResponse(ctx context.Context, body PostRulesKeywordJSONRequestBody, reqEditors ...RequestEditorFn) (*PostRulesKeywordResponse, error) {
	rsp, err := c.PostRulesKeyword(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostRulesKeywordResponse(rsp)
}

// DeleteRulesRuleIdWithResponse request returning *DeleteRulesRuleIdResponse
func (c *ClientWithResponses) DeleteRulesRuleIdWithResponse(ctx context.Context, ruleId PathRuleId, reqEditors ...RequestEditorFn) (*DeleteRulesRuleIdResponse, error) {
	rsp, err := c.DeleteRulesRuleId(ctx, ruleId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteRulesRuleIdResponse(rsp)
}

// GetRulesRuleIdWithResponse request returning *GetRulesRuleIdResponse
func (c *ClientWithResponses) GetRulesRuleIdWithResponse(ctx context.Context, ruleId PathRuleId, reqEditors ...RequestEditorFn) (*GetRulesRuleIdResponse, error) {
	rsp, err := c.GetRulesRuleId(ctx, ruleId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRulesRuleIdResponse(rsp)
}

// PutRulesRuleIdWithBodyWithResponse request with arbitrary body returning *PutRulesRuleIdResponse
func (c *ClientWithResponses) PutRulesRuleIdWithBodyWithResponse(ctx context.Context, ruleId PathRuleId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutRulesRuleIdResponse, error) {
	rsp, err := c.PutRulesRuleIdWithBody(ctx, ruleId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutRulesRuleIdResponse(rsp)
}

func (c *ClientWithResponses) PutRulesRuleIdWithResponse(ctx context.Context, ruleId PathRuleId, body PutRulesRuleIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PutRulesRuleIdResponse, error) {
	rsp, err := c.PutRulesRuleId(ctx, ruleId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutRulesRuleIdResponse(rsp)
}

// PutRulesRuleIdDisableWithResponse request returning *PutRulesRuleIdDisableResponse
func (c *ClientWithResponses) PutRulesRuleIdDisableWithResponse(ctx context.Context, ruleId PathRuleId, reqEditors ...RequestEditorFn) (*PutRulesRuleIdDisableResponse, error) {
	rsp, err := c.PutRulesRuleIdDisable(ctx, ruleId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutRulesRuleIdDisableResponse(rsp)
}

// PutRulesRuleIdEnableWithResponse request returning *PutRulesRuleIdEnableResponse
func (c *ClientWithResponses) PutRulesRuleIdEnableWithResponse(ctx context.Context, ruleId PathRuleId, reqEditors ...RequestEditorFn) (*PutRulesRuleIdEnableResponse, error) {
	rsp, err := c.PutRulesRuleIdEnable(ctx, ruleId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutRulesRuleIdEnableResponse(rsp)
}

// GetSchedulesWithResponse request returning *GetSchedulesResponse
func (c *ClientWithResponses) GetSchedulesWithResponse(ctx context.Context, params *GetSchedulesParams, reqEditors ...RequestEditorFn) (*GetSchedulesResponse, error) {
	rsp, err := c.GetSchedules(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSchedulesResponse(rsp)
}

// GetSchedulesBroadcastingWithResponse request returning *GetSchedulesBroadcastingResponse
func (c *ClientWithResponses) GetSchedulesBroadcastingWithResponse(ctx context.Context, params *GetSchedulesBroadcastingParams, reqEditors ...RequestEditorFn) (*GetSchedulesBroadcastingResponse, error) {
	rsp, err := c.GetSchedulesBroadcasting(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSchedulesBroadcastingResponse(rsp)
}

// GetSchedulesDetailProgramIdWithResponse request returning *GetSchedulesDetailProgramIdResponse
func (c *ClientWithResponses) GetSchedulesDetailProgramIdWithResponse(ctx context.Context, programId PathProgramId, params *GetSchedulesDetailProgramIdParams, reqEditors ...RequestEditorFn) (*GetSchedulesDetailProgramIdResponse, error) {
	rsp, err := c.GetSchedulesDetailProgramId(ctx, programId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSchedulesDetailProgramIdResponse(rsp)
}

// PostSchedulesSearchWithBodyWithResponse request with arbitrary body returning *PostSchedulesSearchResponse
func (c *ClientWithResponses) PostSchedulesSearchWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSchedulesSearchResponse, error) {
	rsp, err := c.PostSchedulesSearchWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSchedulesSearchResponse(rsp)
}

func (c *ClientWithResponses) PostSchedulesSearchWithResponse(ctx context.Context, body PostSchedulesSearchJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSchedulesSearchResponse, error) {
	rsp, err := c.PostSchedulesSearch(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSchedulesSearchResponse(rsp)
}

// GetSchedulesChannelIdWithResponse request returning *GetSchedulesChannelIdResponse
func (c *ClientWithResponses) GetSchedulesChannelIdWithResponse(ctx context.Context, channelId PathChannelId, params *GetSchedulesChannelIdParams, reqEditors ...RequestEditorFn) (*GetSchedulesChannelIdResponse, error) {
	rsp, err := c.GetSchedulesChannelId(ctx, channelId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSchedulesChannelIdResponse(rsp)
}

// GetStoragesWithResponse request returning *GetStoragesResponse
func (c *ClientWithResponses) GetStoragesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetStoragesResponse, error) {
	rsp, err := c.GetStorages(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetStoragesResponse(rsp)
}

// DeleteStreamsWithResponse request returning *DeleteStreamsResponse
func (c *ClientWithResponses) DeleteStreamsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*DeleteStreamsResponse, error) {
	rsp, err := c.DeleteStreams(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteStreamsResponse(rsp)
}

// GetStreamsWithResponse request returning *GetStreamsResponse
func (c *ClientWithResponses) GetStreamsWithResponse(ctx context.Context, params *GetStreamsParams, reqEditors ...RequestEditorFn) (*GetStreamsResponse, error) {
	rsp, err := c.GetStreams(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetStreamsResponse(rsp)
}

// GetStreamsLiveChannelIdHlsWithResponse request returning *GetStreamsLiveChannelIdHlsResponse
func (c *ClientWithResponses) GetStreamsLiveChannelIdHlsWithResponse(ctx context.Context, channelId PathChannelId, params *GetStreamsLiveChannelIdHlsParams, reqEditors ...RequestEditorFn) (*GetStreamsLiveChannelIdHlsResponse, error) {
	rsp, err := c.GetStreamsLiveChannelIdHls(ctx, channelId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetStreamsLiveChannelIdHlsResponse(rsp)
}

// GetStreamsLiveChannelIdM2tsWithResponse request returning *GetStreamsLiveChannelIdM2tsResponse
func (c *ClientWithResponses) GetStreamsLiveChannelIdM2tsWithResponse(ctx context.Context, channelId PathChannelId, params *GetStreamsLiveChannelIdM2tsParams, reqEditors ...RequestEditorFn) (*GetStreamsLiveChannelIdM2tsResponse, error) {
	rsp, err := c.GetStreamsLiveChannelIdM2ts(ctx, channelId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetStreamsLiveChannelIdM2tsResponse(rsp)
}

// GetStreamsLiveChannelIdM2tsPlaylistWithResponse request returning *GetStreamsLiveChannelIdM2tsPlaylistResponse
func (c *ClientWithResponses) GetStreamsLiveChannelIdM2tsPlaylistWithResponse(ctx context.Context, channelId PathChannelId, params *GetStreamsLiveChannelIdM2tsPlaylistParams, reqEditors ...RequestEditorFn) (*GetStreamsLiveChannelIdM2tsPlaylistResponse, error) {
	rsp, err := c.GetStreamsLiveChannelIdM2tsPlaylist(ctx, channelId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetStreamsLiveChannelIdM2tsPlaylistResponse(rsp)
}

// GetStreamsLiveChannelIdM2tsllWithResponse request returning *GetStreamsLiveChannelIdM2tsllResponse
func (c *ClientWithResponses) GetStreamsLiveChannelIdM2tsllWithResponse(ctx context.Context, channelId PathChannelId, params *GetStreamsLiveChannelIdM2tsllParams, reqEditors ...RequestEditorFn) (*GetStreamsLiveChannelIdM2tsllResponse, error) {
	rsp, err := c.GetStreamsLiveChannelIdM2tsll(ctx, channelId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetStreamsLiveChannelIdM2tsllResponse(rsp)
}

// GetStreamsLiveChannelIdMp4WithResponse request returning *GetStreamsLiveChannelIdMp4Response
func (c *ClientWithResponses) GetStreamsLiveChannelIdMp4WithResponse(ctx context.Context, channelId PathChannelId, params *GetStreamsLiveChannelIdMp4Params, reqEditors ...RequestEditorFn) (*GetStreamsLiveChannelIdMp4Response, error) {
	rsp, err := c.GetStreamsLiveChannelIdMp4(ctx, channelId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetStreamsLiveChannelIdMp4Response(rsp)
}

// GetStreamsLiveChannelIdWebmWithResponse request returning *GetStreamsLiveChannelIdWebmResponse
func (c *ClientWithResponses) GetStreamsLiveChannelIdWebmWithResponse(ctx context.Context, channelId PathChannelId, params *GetStreamsLiveChannelIdWebmParams, reqEditors ...RequestEditorFn) (*GetStreamsLiveChannelIdWebmResponse, error) {
	rsp, err := c.GetStreamsLiveChannelIdWebm(ctx, channelId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetStreamsLiveChannelIdWebmResponse(rsp)
}

// GetStreamsRecordedVideoFileIdHlsWithResponse request returning *GetStreamsRecordedVideoFileIdHlsResponse
func (c *ClientWithResponses) GetStreamsRecordedVideoFileIdHlsWithResponse(ctx context.Context, videoFileId PathVideoFileId, params *GetStreamsRecordedVideoFileIdHlsParams, reqEditors ...RequestEditorFn) (*GetStreamsRecordedVideoFileIdHlsResponse, error) {
	rsp, err := c.GetStreamsRecordedVideoFileIdHls(ctx, videoFileId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetStreamsRecordedVideoFileIdHlsResponse(rsp)
}

// GetStreamsRecordedVideoFileIdMp4WithResponse request returning *GetStreamsRecordedVideoFileIdMp4Response
func (c *ClientWithResponses) GetStreamsRecordedVideoFileIdMp4WithResponse(ctx context.Context, videoFileId PathVideoFileId, params *GetStreamsRecordedVideoFileIdMp4Params, reqEditors ...RequestEditorFn) (*GetStreamsRecordedVideoFileIdMp4Response, error) {
	rsp, err := c.GetStreamsRecordedVideoFileIdMp4(ctx, videoFileId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetStreamsRecordedVideoFileIdMp4Response(rsp)
}

// GetStreamsRecordedVideoFileIdWebmWithResponse request returning *GetStreamsRecordedVideoFileIdWebmResponse
func (c *ClientWithResponses) GetStreamsRecordedVideoFileIdWebmWithResponse(ctx context.Context, videoFileId PathVideoFileId, params *GetStreamsRecordedVideoFileIdWebmParams, reqEditors ...RequestEditorFn) (*GetStreamsRecordedVideoFileIdWebmResponse, error) {
	rsp, err := c.GetStreamsRecordedVideoFileIdWebm(ctx, videoFileId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetStreamsRecordedVideoFileIdWebmResponse(rsp)
}

// DeleteStreamsStreamIdWithResponse request returning *DeleteStreamsStreamIdResponse
func (c *ClientWithResponses) DeleteStreamsStreamIdWithResponse(ctx context.Context, streamId PathStreamId, reqEditors ...RequestEditorFn) (*DeleteStreamsStreamIdResponse, error) {
	rsp, err := c.DeleteStreamsStreamId(ctx, streamId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteStreamsStreamIdResponse(rsp)
}

// PutStreamsStreamIdKeepWithResponse request returning *PutStreamsStreamIdKeepResponse
func (c *ClientWithResponses) PutStreamsStreamIdKeepWithResponse(ctx context.Context, streamId PathStreamId, reqEditors ...RequestEditorFn) (*PutStreamsStreamIdKeepResponse, error) {
	rsp, err := c.PutStreamsStreamIdKeep(ctx, streamId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutStreamsStreamIdKeepResponse(rsp)
}

// GetTagsWithResponse request returning *GetTagsResponse
func (c *ClientWithResponses) GetTagsWithResponse(ctx context.Context, params *GetTagsParams, reqEditors ...RequestEditorFn) (*GetTagsResponse, error) {
	rsp, err := c.GetTags(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTagsResponse(rsp)
}

// PostTagsWithBodyWithResponse request with arbitrary body returning *PostTagsResponse
func (c *ClientWithResponses) PostTagsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostTagsResponse, error) {
	rsp, err := c.PostTagsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostTagsResponse(rsp)
}

func (c *ClientWithResponses) PostTagsWithResponse(ctx context.Context, body PostTagsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostTagsResponse, error) {
	rsp, err := c.PostTags(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostTagsResponse(rsp)
}

// DeleteTagsTagIdWithResponse request returning *DeleteTagsTagIdResponse
func (c *ClientWithResponses) DeleteTagsTagIdWithResponse(ctx context.Context, tagId PathRecordedTagId, reqEditors ...RequestEditorFn) (*DeleteTagsTagIdResponse, error) {
	rsp, err := c.DeleteTagsTagId(ctx, tagId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteTagsTagIdResponse(rsp)
}

// PutTagsTagIdWithBodyWithResponse request with arbitrary body returning *PutTagsTagIdResponse
func (c *ClientWithResponses) PutTagsTagIdWithBodyWithResponse(ctx context.Context, tagId PathRecordedTagId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutTagsTagIdResponse, error) {
	rsp, err := c.PutTagsTagIdWithBody(ctx, tagId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutTagsTagIdResponse(rsp)
}

func (c *ClientWithResponses) PutTagsTagIdWithResponse(ctx context.Context, tagId PathRecordedTagId, body PutTagsTagIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PutTagsTagIdResponse, error) {
	rsp, err := c.PutTagsTagId(ctx, tagId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutTagsTagIdResponse(rsp)
}

// DeleteTagsTagIdRelateWithResponse request returning *DeleteTagsTagIdRelateResponse
func (c *ClientWithResponses) DeleteTagsTagIdRelateWithResponse(ctx context.Context, tagId PathRecordedTagId, params *DeleteTagsTagIdRelateParams, reqEditors ...RequestEditorFn) (*DeleteTagsTagIdRelateResponse, error) {
	rsp, err := c.DeleteTagsTagIdRelate(ctx, tagId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteTagsTagIdRelateResponse(rsp)
}

// PutTagsTagIdRelateWithBodyWithResponse request with arbitrary body returning *PutTagsTagIdRelateResponse
func (c *ClientWithResponses) PutTagsTagIdRelateWithBodyWithResponse(ctx context.Context, tagId PathRecordedTagId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutTagsTagIdRelateResponse, error) {
	rsp, err := c.PutTagsTagIdRelateWithBody(ctx, tagId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutTagsTagIdRelateResponse(rsp)
}

func (c *ClientWithResponses) PutTagsTagIdRelateWithResponse(ctx context.Context, tagId PathRecordedTagId, body PutTagsTagIdRelateJSONRequestBody, reqEditors ...RequestEditorFn) (*PutTagsTagIdRelateResponse, error) {
	rsp, err := c.PutTagsTagIdRelate(ctx, tagId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutTagsTagIdRelateResponse(rsp)
}

// PostThumbnailsWithResponse request returning *PostThumbnailsResponse
func (c *ClientWithResponses) PostThumbnailsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*PostThumbnailsResponse, error) {
	rsp, err := c.PostThumbnails(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostThumbnailsResponse(rsp)
}

// PostThumbnailsCleanupWithResponse request returning *PostThumbnailsCleanupResponse
func (c *ClientWithResponses) PostThumbnailsCleanupWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*PostThumbnailsCleanupResponse, error) {
	rsp, err := c.PostThumbnailsCleanup(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostThumbnailsCleanupResponse(rsp)
}

// GetThumbnailsThumbnailIdWithResponse request returning *GetThumbnailsThumbnailIdResponse
func (c *ClientWithResponses) GetThumbnailsThumbnailIdWithResponse(ctx context.Context, thumbnailId PathThumbnailId, reqEditors ...RequestEditorFn) (*GetThumbnailsThumbnailIdResponse, error) {
	rsp, err := c.GetThumbnailsThumbnailId(ctx, thumbnailId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetThumbnailsThumbnailIdResponse(rsp)
}

// GetVersionWithResponse request returning *GetVersionResponse
func (c *ClientWithResponses) GetVersionWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetVersionResponse, error) {
	rsp, err := c.GetVersion(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetVersionResponse(rsp)
}

// PostVideosUploadWithBodyWithResponse request with arbitrary body returning *PostVideosUploadResponse
func (c *ClientWithResponses) PostVideosUploadWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostVideosUploadResponse, error) {
	rsp, err := c.PostVideosUploadWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostVideosUploadResponse(rsp)
}

// DeleteVideosVideoFileIdWithResponse request returning *DeleteVideosVideoFileIdResponse
func (c *ClientWithResponses) DeleteVideosVideoFileIdWithResponse(ctx context.Context, videoFileId PathVideoFileId, reqEditors ...RequestEditorFn) (*DeleteVideosVideoFileIdResponse, error) {
	rsp, err := c.DeleteVideosVideoFileId(ctx, videoFileId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteVideosVideoFileIdResponse(rsp)
}

// GetVideosVideoFileIdWithResponse request returning *GetVideosVideoFileIdResponse
func (c *ClientWithResponses) GetVideosVideoFileIdWithResponse(ctx context.Context, videoFileId PathVideoFileId, params *GetVideosVideoFileIdParams, reqEditors ...RequestEditorFn) (*GetVideosVideoFileIdResponse, error) {
	rsp, err := c.GetVideosVideoFileId(ctx, videoFileId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetVideosVideoFileIdResponse(rsp)
}

// GetVideosVideoFileIdDurationWithResponse request returning *GetVideosVideoFileIdDurationResponse
func (c *ClientWithResponses) GetVideosVideoFileIdDurationWithResponse(ctx context.Context, videoFileId PathVideoFileId, reqEditors ...RequestEditorFn) (*GetVideosVideoFileIdDurationResponse, error) {
	rsp, err := c.GetVideosVideoFileIdDuration(ctx, videoFileId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetVideosVideoFileIdDurationResponse(rsp)
}

// PostVideosVideoFileIdKodiWithBodyWithResponse request with arbitrary body returning *PostVideosVideoFileIdKodiResponse
func (c *ClientWithResponses) PostVideosVideoFileIdKodiWithBodyWithResponse(ctx context.Context, videoFileId PathVideoFileId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostVideosVideoFileIdKodiResponse, error) {
	rsp, err := c.PostVideosVideoFileIdKodiWithBody(ctx, videoFileId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostVideosVideoFileIdKodiResponse(rsp)
}

func (c *ClientWithResponses) PostVideosVideoFileIdKodiWithResponse(ctx context.Context, videoFileId PathVideoFileId, body PostVideosVideoFileIdKodiJSONRequestBody, reqEditors ...RequestEditorFn) (*PostVideosVideoFileIdKodiResponse, error) {
	rsp, err := c.PostVideosVideoFileIdKodi(ctx, videoFileId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostVideosVideoFileIdKodiResponse(rsp)
}

// GetVideosVideoFileIdPlaylistWithResponse request returning *GetVideosVideoFileIdPlaylistResponse
func (c *ClientWithResponses) GetVideosVideoFileIdPlaylistWithResponse(ctx context.Context, videoFileId PathVideoFileId, reqEditors ...RequestEditorFn) (*GetVideosVideoFileIdPlaylistResponse, error) {
	rsp, err := c.GetVideosVideoFileIdPlaylist(ctx, videoFileId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetVideosVideoFileIdPlaylistResponse(rsp)
}

// ParseGetChannelsResponse parses an HTTP response from a GetChannelsWithResponse call
func ParseGetChannelsResponse(rsp *http.Response) (*GetChannelsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetChannelsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ChannelItems
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetChannelsChannelIdLogoResponse parses an HTTP response from a GetChannelsChannelIdLogoWithResponse call
func ParseGetChannelsChannelIdLogoResponse(rsp *http.Response) (*GetChannelsChannelIdLogoResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetChannelsChannelIdLogoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetConfigResponse parses an HTTP response from a GetConfigWithResponse call
func ParseGetConfigResponse(rsp *http.Response) (*GetConfigResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetConfigResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Config
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetDropLogsDropLogFileIdResponse parses an HTTP response from a GetDropLogsDropLogFileIdWithResponse call
func ParseGetDropLogsDropLogFileIdResponse(rsp *http.Response) (*GetDropLogsDropLogFileIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDropLogsDropLogFileIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetEncodeResponse parses an HTTP response from a GetEncodeWithResponse call
func ParseGetEncodeResponse(rsp *http.Response) (*GetEncodeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetEncodeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EncodeInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePostEncodeResponse parses an HTTP response from a PostEncodeWithResponse call
func ParsePostEncodeResponse(rsp *http.Response) (*PostEncodeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostEncodeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest AddedEncode
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteEncodeEncodeIdResponse parses an HTTP response from a DeleteEncodeEncodeIdWithResponse call
func ParseDeleteEncodeEncodeIdResponse(rsp *http.Response) (*DeleteEncodeEncodeIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteEncodeEncodeIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetIptvChannelM3u8Response parses an HTTP response from a GetIptvChannelM3u8WithResponse call
func ParseGetIptvChannelM3u8Response(rsp *http.Response) (*GetIptvChannelM3u8Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetIptvChannelM3u8Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetIptvEpgXmlResponse parses an HTTP response from a GetIptvEpgXmlWithResponse call
func ParseGetIptvEpgXmlResponse(rsp *http.Response) (*GetIptvEpgXmlResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetIptvEpgXmlResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetRecordedResponse parses an HTTP response from a GetRecordedWithResponse call
func ParseGetRecordedResponse(rsp *http.Response) (*GetRecordedResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRecordedResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Records
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePostRecordedResponse parses an HTTP response from a PostRecordedWithResponse call
func ParsePostRecordedResponse(rsp *http.Response) (*PostRecordedResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostRecordedResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest CreatedNewRecorded
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePostRecordedCleanupResponse parses an HTTP response from a PostRecordedCleanupWithResponse call
func ParsePostRecordedCleanupResponse(rsp *http.Response) (*PostRecordedCleanupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostRecordedCleanupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetRecordedOptionsResponse parses an HTTP response from a GetRecordedOptionsWithResponse call
func ParseGetRecordedOptionsResponse(rsp *http.Response) (*GetRecordedOptionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRecordedOptionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RecordedSearchOptions
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteRecordedRecordedIdResponse parses an HTTP response from a DeleteRecordedRecordedIdWithResponse call
func ParseDeleteRecordedRecordedIdResponse(rsp *http.Response) (*DeleteRecordedRecordedIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteRecordedRecordedIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetRecordedRecordedIdResponse parses an HTTP response from a GetRecordedRecordedIdWithResponse call
func ParseGetRecordedRecordedIdResponse(rsp *http.Response) (*GetRecordedRecordedIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRecordedRecordedIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RecordedItem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteRecordedRecordedIdEncodeResponse parses an HTTP response from a DeleteRecordedRecordedIdEncodeWithResponse call
func ParseDeleteRecordedRecordedIdEncodeResponse(rsp *http.Response) (*DeleteRecordedRecordedIdEncodeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteRecordedRecordedIdEncodeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePutRecordedRecordedIdProtectResponse parses an HTTP response from a PutRecordedRecordedIdProtectWithResponse call
func ParsePutRecordedRecordedIdProtectResponse(rsp *http.Response) (*PutRecordedRecordedIdProtectResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PutRecordedRecordedIdProtectResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePutRecordedRecordedIdUnprotectResponse parses an HTTP response from a PutRecordedRecordedIdUnprotectWithResponse call
func ParsePutRecordedRecordedIdUnprotectResponse(rsp *http.Response) (*PutRecordedRecordedIdUnprotectResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PutRecordedRecordedIdUnprotectResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetRecordingResponse parses an HTTP response from a GetRecordingWithResponse call
func ParseGetRecordingResponse(rsp *http.Response) (*GetRecordingResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRecordingResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Records
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePostRecordingResettimerResponse parses an HTTP response from a PostRecordingResettimerWithResponse call
func ParsePostRecordingResettimerResponse(rsp *http.Response) (*PostRecordingResettimerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostRecordingResettimerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetReservesResponse parses an HTTP response from a GetReservesWithResponse call
func ParseGetReservesResponse(rsp *http.Response) (*GetReservesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetReservesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Reserves
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePostReservesResponse parses an HTTP response from a PostReservesWithResponse call
func ParsePostReservesResponse(rsp *http.Response) (*PostReservesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostReservesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest AddedReserve
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetReservesCntsResponse parses an HTTP response from a GetReservesCntsWithResponse call
func ParseGetReservesCntsResponse(rsp *http.Response) (*GetReservesCntsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetReservesCntsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReserveCnts
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetReservesListsResponse parses an HTTP response from a GetReservesListsWithResponse call
func ParseGetReservesListsResponse(rsp *http.Response) (*GetReservesListsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetReservesListsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReserveLists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePostReservesUpdateResponse parses an HTTP response from a PostReservesUpdateWithResponse call
func ParsePostReservesUpdateResponse(rsp *http.Response) (*PostReservesUpdateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostReservesUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteReservesReserveIdResponse parses an HTTP response from a DeleteReservesReserveIdWithResponse call
func ParseDeleteReservesReserveIdResponse(rsp *http.Response) (*DeleteReservesReserveIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteReservesReserveIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetReservesReserveIdResponse parses an HTTP response from a GetReservesReserveIdWithResponse call
func ParseGetReservesReserveIdResponse(rsp *http.Response) (*GetReservesReserveIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetReservesReserveIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReserveItem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePutReservesReserveIdResponse parses an HTTP response from a PutReservesReserveIdWithResponse call
func ParsePutReservesReserveIdResponse(rsp *http.Response) (*PutReservesReserveIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PutReservesReserveIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteReservesReserveIdOverlapResponse parses an HTTP response from a DeleteReservesReserveIdOverlapWithResponse call
func ParseDeleteReservesReserveIdOverlapResponse(rsp *http.Response) (*DeleteReservesReserveIdOverlapResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteReservesReserveIdOverlapResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteReservesReserveIdSkipResponse parses an HTTP response from a DeleteReservesReserveIdSkipWithResponse call
func ParseDeleteReservesReserveIdSkipResponse(rsp *http.Response) (*DeleteReservesReserveIdSkipResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteReservesReserveIdSkipResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetRulesResponse parses an HTTP response from a GetRulesWithResponse call
func ParseGetRulesResponse(rsp *http.Response) (*GetRulesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRulesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Rules
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePostRulesResponse parses an HTTP response from a PostRulesWithResponse call
func ParsePostRulesResponse(rsp *http.Response) (*PostRulesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostRulesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest AddedRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetRulesKeywordResponse parses an HTTP response from a GetRulesKeywordWithResponse call
func ParseGetRulesKeywordResponse(rsp *http.Response) (*GetRulesKeywordResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRulesKeywordResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RuleKeywordInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePostRulesKeywordResponse parses an HTTP response from a PostRulesKeywordWithResponse call
func ParsePostRulesKeywordResponse(rsp *http.Response) (*PostRulesKeywordResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostRulesKeywordResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest AddedRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteRulesRuleIdResponse parses an HTTP response from a DeleteRulesRuleIdWithResponse call
func ParseDeleteRulesRuleIdResponse(rsp *http.Response) (*DeleteRulesRuleIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteRulesRuleIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetRulesRuleIdResponse parses an HTTP response from a GetRulesRuleIdWithResponse call
func ParseGetRulesRuleIdResponse(rsp *http.Response) (*GetRulesRuleIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRulesRuleIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Rule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePutRulesRuleIdResponse parses an HTTP response from a PutRulesRuleIdWithResponse call
func ParsePutRulesRuleIdResponse(rsp *http.Response) (*PutRulesRuleIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PutRulesRuleIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePutRulesRuleIdDisableResponse parses an HTTP response from a PutRulesRuleIdDisableWithResponse call
func ParsePutRulesRuleIdDisableResponse(rsp *http.Response) (*PutRulesRuleIdDisableResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PutRulesRuleIdDisableResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePutRulesRuleIdEnableResponse parses an HTTP response from a PutRulesRuleIdEnableWithResponse call
func ParsePutRulesRuleIdEnableResponse(rsp *http.Response) (*PutRulesRuleIdEnableResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PutRulesRuleIdEnableResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetSchedulesResponse parses an HTTP response from a GetSchedulesWithResponse call
func ParseGetSchedulesResponse(rsp *http.Response) (*GetSchedulesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSchedulesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Schedules
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetSchedulesBroadcastingResponse parses an HTTP response from a GetSchedulesBroadcastingWithResponse call
func ParseGetSchedulesBroadcastingResponse(rsp *http.Response) (*GetSchedulesBroadcastingResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSchedulesBroadcastingResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Schedules
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetSchedulesDetailProgramIdResponse parses an HTTP response from a GetSchedulesDetailProgramIdWithResponse call
func ParseGetSchedulesDetailProgramIdResponse(rsp *http.Response) (*GetSchedulesDetailProgramIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSchedulesDetailProgramIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ScheduleProgramItem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePostSchedulesSearchResponse parses an HTTP response from a PostSchedulesSearchWithResponse call
func ParsePostSchedulesSearchResponse(rsp *http.Response) (*PostSchedulesSearchResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostSchedulesSearchResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []ScheduleProgramItem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetSchedulesChannelIdResponse parses an HTTP response from a GetSchedulesChannelIdWithResponse call
func ParseGetSchedulesChannelIdResponse(rsp *http.Response) (*GetSchedulesChannelIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSchedulesChannelIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Schedules
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetStoragesResponse parses an HTTP response from a GetStoragesWithResponse call
func ParseGetStoragesResponse(rsp *http.Response) (*GetStoragesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetStoragesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StorageInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteStreamsResponse parses an HTTP response from a DeleteStreamsWithResponse call
func ParseDeleteStreamsResponse(rsp *http.Response) (*DeleteStreamsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteStreamsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetStreamsResponse parses an HTTP response from a GetStreamsWithResponse call
func ParseGetStreamsResponse(rsp *http.Response) (*GetStreamsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetStreamsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StreamInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetStreamsLiveChannelIdHlsResponse parses an HTTP response from a GetStreamsLiveChannelIdHlsWithResponse call
func ParseGetStreamsLiveChannelIdHlsResponse(rsp *http.Response) (*GetStreamsLiveChannelIdHlsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetStreamsLiveChannelIdHlsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StartStreamInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetStreamsLiveChannelIdM2tsResponse parses an HTTP response from a GetStreamsLiveChannelIdM2tsWithResponse call
func ParseGetStreamsLiveChannelIdM2tsResponse(rsp *http.Response) (*GetStreamsLiveChannelIdM2tsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetStreamsLiveChannelIdM2tsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetStreamsLiveChannelIdM2tsPlaylistResponse parses an HTTP response from a GetStreamsLiveChannelIdM2tsPlaylistWithResponse call
func ParseGetStreamsLiveChannelIdM2tsPlaylistResponse(rsp *http.Response) (*GetStreamsLiveChannelIdM2tsPlaylistResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetStreamsLiveChannelIdM2tsPlaylistResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetStreamsLiveChannelIdM2tsllResponse parses an HTTP response from a GetStreamsLiveChannelIdM2tsllWithResponse call
func ParseGetStreamsLiveChannelIdM2tsllResponse(rsp *http.Response) (*GetStreamsLiveChannelIdM2tsllResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetStreamsLiveChannelIdM2tsllResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetStreamsLiveChannelIdMp4Response parses an HTTP response from a GetStreamsLiveChannelIdMp4WithResponse call
func ParseGetStreamsLiveChannelIdMp4Response(rsp *http.Response) (*GetStreamsLiveChannelIdMp4Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetStreamsLiveChannelIdMp4Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetStreamsLiveChannelIdWebmResponse parses an HTTP response from a GetStreamsLiveChannelIdWebmWithResponse call
func ParseGetStreamsLiveChannelIdWebmResponse(rsp *http.Response) (*GetStreamsLiveChannelIdWebmResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetStreamsLiveChannelIdWebmResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetStreamsRecordedVideoFileIdHlsResponse parses an HTTP response from a GetStreamsRecordedVideoFileIdHlsWithResponse call
func ParseGetStreamsRecordedVideoFileIdHlsResponse(rsp *http.Response) (*GetStreamsRecordedVideoFileIdHlsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetStreamsRecordedVideoFileIdHlsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StartStreamInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetStreamsRecordedVideoFileIdMp4Response parses an HTTP response from a GetStreamsRecordedVideoFileIdMp4WithResponse call
func ParseGetStreamsRecordedVideoFileIdMp4Response(rsp *http.Response) (*GetStreamsRecordedVideoFileIdMp4Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetStreamsRecordedVideoFileIdMp4Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetStreamsRecordedVideoFileIdWebmResponse parses an HTTP response from a GetStreamsRecordedVideoFileIdWebmWithResponse call
func ParseGetStreamsRecordedVideoFileIdWebmResponse(rsp *http.Response) (*GetStreamsRecordedVideoFileIdWebmResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetStreamsRecordedVideoFileIdWebmResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteStreamsStreamIdResponse parses an HTTP response from a DeleteStreamsStreamIdWithResponse call
func ParseDeleteStreamsStreamIdResponse(rsp *http.Response) (*DeleteStreamsStreamIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteStreamsStreamIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePutStreamsStreamIdKeepResponse parses an HTTP response from a PutStreamsStreamIdKeepWithResponse call
func ParsePutStreamsStreamIdKeepResponse(rsp *http.Response) (*PutStreamsStreamIdKeepResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PutStreamsStreamIdKeepResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetTagsResponse parses an HTTP response from a GetTagsWithResponse call
func ParseGetTagsResponse(rsp *http.Response) (*GetTagsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTagsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RecordedTags
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePostTagsResponse parses an HTTP response from a PostTagsWithResponse call
func ParsePostTagsResponse(rsp *http.Response) (*PostTagsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostTagsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest AddedRecordedTag
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteTagsTagIdResponse parses an HTTP response from a DeleteTagsTagIdWithResponse call
func ParseDeleteTagsTagIdResponse(rsp *http.Response) (*DeleteTagsTagIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteTagsTagIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePutTagsTagIdResponse parses an HTTP response from a PutTagsTagIdWithResponse call
func ParsePutTagsTagIdResponse(rsp *http.Response) (*PutTagsTagIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PutTagsTagIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteTagsTagIdRelateResponse parses an HTTP response from a DeleteTagsTagIdRelateWithResponse call
func ParseDeleteTagsTagIdRelateResponse(rsp *http.Response) (*DeleteTagsTagIdRelateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteTagsTagIdRelateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePutTagsTagIdRelateResponse parses an HTTP response from a PutTagsTagIdRelateWithResponse call
func ParsePutTagsTagIdRelateResponse(rsp *http.Response) (*PutTagsTagIdRelateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PutTagsTagIdRelateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePostThumbnailsResponse parses an HTTP response from a PostThumbnailsWithResponse call
func ParsePostThumbnailsResponse(rsp *http.Response) (*PostThumbnailsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostThumbnailsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePostThumbnailsCleanupResponse parses an HTTP response from a PostThumbnailsCleanupWithResponse call
func ParsePostThumbnailsCleanupResponse(rsp *http.Response) (*PostThumbnailsCleanupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostThumbnailsCleanupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetThumbnailsThumbnailIdResponse parses an HTTP response from a GetThumbnailsThumbnailIdWithResponse call
func ParseGetThumbnailsThumbnailIdResponse(rsp *http.Response) (*GetThumbnailsThumbnailIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetThumbnailsThumbnailIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetVersionResponse parses an HTTP response from a GetVersionWithResponse call
func ParseGetVersionResponse(rsp *http.Response) (*GetVersionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetVersionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Version
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePostVideosUploadResponse parses an HTTP response from a PostVideosUploadWithResponse call
func ParsePostVideosUploadResponse(rsp *http.Response) (*PostVideosUploadResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostVideosUploadResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteVideosVideoFileIdResponse parses an HTTP response from a DeleteVideosVideoFileIdWithResponse call
func ParseDeleteVideosVideoFileIdResponse(rsp *http.Response) (*DeleteVideosVideoFileIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteVideosVideoFileIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetVideosVideoFileIdResponse parses an HTTP response from a GetVideosVideoFileIdWithResponse call
func ParseGetVideosVideoFileIdResponse(rsp *http.Response) (*GetVideosVideoFileIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetVideosVideoFileIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetVideosVideoFileIdDurationResponse parses an HTTP response from a GetVideosVideoFileIdDurationWithResponse call
func ParseGetVideosVideoFileIdDurationResponse(rsp *http.Response) (*GetVideosVideoFileIdDurationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetVideosVideoFileIdDurationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VideoFileDuration
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePostVideosVideoFileIdKodiResponse parses an HTTP response from a PostVideosVideoFileIdKodiWithResponse call
func ParsePostVideosVideoFileIdKodiResponse(rsp *http.Response) (*PostVideosVideoFileIdKodiResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostVideosVideoFileIdKodiResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetVideosVideoFileIdPlaylistResponse parses an HTTP response from a GetVideosVideoFileIdPlaylistWithResponse call
func ParseGetVideosVideoFileIdPlaylistResponse(rsp *http.Response) (*GetVideosVideoFileIdPlaylistResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetVideosVideoFileIdPlaylistResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// 放送局情報取得
	// (GET /channels)
	GetChannels(ctx echo.Context) error
	// 放送局ロゴ取得
	// (GET /channels/{channelId}/logo)
	GetChannelsChannelIdLogo(ctx echo.Context, channelId PathChannelId) error
	// config 情報取得
	// (GET /config)
	GetConfig(ctx echo.Context) error
	// ドロップログ
	// (GET /dropLogs/{dropLogFileId})
	GetDropLogsDropLogFileId(ctx echo.Context, dropLogFileId PathDropLogFileId, params GetDropLogsDropLogFileIdParams) error
	// エンコード情報取得
	// (GET /encode)
	GetEncode(ctx echo.Context, params GetEncodeParams) error
	// エンコード追加
	// (POST /encode)
	PostEncode(ctx echo.Context) error
	// エンコードをキャンセル
	// (DELETE /encode/{encodeId})
	DeleteEncodeEncodeId(ctx echo.Context, encodeId PathEncodeId) error
	// IPTV channel list を取得
	// (GET /iptv/channel.m3u8)
	GetIptvChannelM3u8(ctx echo.Context, params GetIptvChannelM3u8Params) error
	// IPTV epg を取得
	// (GET /iptv/epg.xml)
	GetIptvEpgXml(ctx echo.Context, params GetIptvEpgXmlParams) error
	// 録画情報取得
	// (GET /recorded)
	GetRecorded(ctx echo.Context, params GetRecordedParams) error
	// 録画番組情報の新規作成
	// (POST /recorded)
	PostRecorded(ctx echo.Context) error
	// 録画をクリーンアップ
	// (POST /recorded/cleanup)
	PostRecordedCleanup(ctx echo.Context) error
	// 録画検索オプションを取得
	// (GET /recorded/options)
	GetRecordedOptions(ctx echo.Context) error
	// 録画を削除
	// (DELETE /recorded/{recordedId})
	DeleteRecordedRecordedId(ctx echo.Context, recordedId PathRecordedId) error
	// 録画詳細情報を取得
	// (GET /recorded/{recordedId})
	GetRecordedRecordedId(ctx echo.Context, recordedId PathRecordedId, params GetRecordedRecordedIdParams) error
	// エンコード停止
	// (DELETE /recorded/{recordedId}/encode)
	DeleteRecordedRecordedIdEncode(ctx echo.Context, recordedId PathRecordedId) error
	// 録画を自動削除対象から除外
	// (PUT /recorded/{recordedId}/protect)
	PutRecordedRecordedIdProtect(ctx echo.Context, recordedId PathRecordedId) error
	// 録画を自動削除対象に戻す
	// (PUT /recorded/{recordedId}/unprotect)
	PutRecordedRecordedIdUnprotect(ctx echo.Context, recordedId PathRecordedId) error
	// 録画中情報取得
	// (GET /recording)
	GetRecording(ctx echo.Context, params GetRecordingParams) error
	// 予約タイマー再設定
	// (POST /recording/resettimer)
	PostRecordingResettimer(ctx echo.Context) error
	// 予約情報取得
	// (GET /reserves)
	GetReserves(ctx echo.Context, params GetReservesParams) error
	// 予約追加
	// (POST /reserves)
	PostReserves(ctx echo.Context) error
	// 予約数取得
	// (GET /reserves/cnts)
	GetReservesCnts(ctx echo.Context) error
	// 予約リスト情報取得
	// (GET /reserves/lists)
	GetReservesLists(ctx echo.Context, params GetReservesListsParams) error
	// 予約情報の更新開始
	// (POST /reserves/update)
	PostReservesUpdate(ctx echo.Context) error
	// 予約削除
	// (DELETE /reserves/{reserveId})
	DeleteReservesReserveId(ctx echo.Context, reserveId PathReserveId) error
	// 指定された予約情報の取得
	// (GET /reserves/{reserveId})
	GetReservesReserveId(ctx echo.Context, reserveId PathReserveId, params GetReservesReserveIdParams) error
	// 手動予約更新
	// (PUT /reserves/{reserveId})
	PutReservesReserveId(ctx echo.Context, reserveId PathReserveId) error
	// 予約の重複状態を解除
	// (DELETE /reserves/{reserveId}/overlap)
	DeleteReservesReserveIdOverlap(ctx echo.Context, reserveId PathReserveId) error
	// 予約の除外状態を解除
	// (DELETE /reserves/{reserveId}/skip)
	DeleteReservesReserveIdSkip(ctx echo.Context, reserveId PathReserveId) error
	// ルール情報取得
	// (GET /rules)
	GetRules(ctx echo.Context, params GetRulesParams) error
	// ルール追加
	// (POST /rules)
	PostRules(ctx echo.Context) error
	// ルールをキーワード検索
	// (GET /rules/keyword)
	GetRulesKeyword(ctx echo.Context, params GetRulesKeywordParams) error
	// ルール追加
	// (POST /rules/keyword)
	PostRulesKeyword(ctx echo.Context) error
	// ルール削除
	// (DELETE /rules/{ruleId})
	DeleteRulesRuleId(ctx echo.Context, ruleId PathRuleId) error
	// ルール取得
	// (GET /rules/{ruleId})
	GetRulesRuleId(ctx echo.Context, ruleId PathRuleId) error
	// ルール更新
	// (PUT /rules/{ruleId})
	PutRulesRuleId(ctx echo.Context, ruleId PathRuleId) error
	// ルール無効化
	// (PUT /rules/{ruleId}/disable)
	PutRulesRuleIdDisable(ctx echo.Context, ruleId PathRuleId) error
	// ルール有効化
	// (PUT /rules/{ruleId}/enable)
	PutRulesRuleIdEnable(ctx echo.Context, ruleId PathRuleId) error
	// 番組表情報取得
	// (GET /schedules)
	GetSchedules(ctx echo.Context, params GetSchedulesParams) error
	// 放映中の番組報取得
	// (GET /schedules/broadcasting)
	GetSchedulesBroadcasting(ctx echo.Context, params GetSchedulesBroadcastingParams) error
	// 指定された番組表情報取得
	// (GET /schedules/detail/{programId})
	GetSchedulesDetailProgramId(ctx echo.Context, programId PathProgramId, params GetSchedulesDetailProgramIdParams) error
	// 番組検索結果を取得
	// (POST /schedules/search)
	PostSchedulesSearch(ctx echo.Context) error
	// 指定された放送局の番組表情報取得
	// (GET /schedules/{channelId})
	GetSchedulesChannelId(ctx echo.Context, channelId PathChannelId, params GetSchedulesChannelIdParams) error
	// ストレージ情報取得
	// (GET /storages)
	GetStorages(ctx echo.Context) error
	// 全てのストリームを停止
	// (DELETE /streams)
	DeleteStreams(ctx echo.Context) error
	// ストリーム情報を取得
	// (GET /streams)
	GetStreams(ctx echo.Context, params GetStreamsParams) error
	// ライブ HLS ストリーム
	// (GET /streams/live/{channelId}/hls)
	GetStreamsLiveChannelIdHls(ctx echo.Context, channelId PathChannelId, params GetStreamsLiveChannelIdHlsParams) error
	// ライブ M2TS ストリーム
	// (GET /streams/live/{channelId}/m2ts)
	GetStreamsLiveChannelIdM2ts(ctx echo.Context, channelId PathChannelId, params GetStreamsLiveChannelIdM2tsParams) error
	// ライブ M2TS ストリームプレイリスト
	// (GET /streams/live/{channelId}/m2ts/playlist)
	GetStreamsLiveChannelIdM2tsPlaylist(ctx echo.Context, channelId PathChannelId, params GetStreamsLiveChannelIdM2tsPlaylistParams) error
	// ライブ M2TS Low Latency (mpegts.js 用) ストリーム
	// (GET /streams/live/{channelId}/m2tsll)
	GetStreamsLiveChannelIdM2tsll(ctx echo.Context, channelId PathChannelId, params GetStreamsLiveChannelIdM2tsllParams) error
	// ライブ mp4 ストリーム
	// (GET /streams/live/{channelId}/mp4)
	GetStreamsLiveChannelIdMp4(ctx echo.Context, channelId PathChannelId, params GetStreamsLiveChannelIdMp4Params) error
	// ライブ WebM ストリーム
	// (GET /streams/live/{channelId}/webm)
	GetStreamsLiveChannelIdWebm(ctx echo.Context, channelId PathChannelId, params GetStreamsLiveChannelIdWebmParams) error
	// 録画 HLS ストリーム
	// (GET /streams/recorded/{videoFileId}/hls)
	GetStreamsRecordedVideoFileIdHls(ctx echo.Context, videoFileId PathVideoFileId, params GetStreamsRecordedVideoFileIdHlsParams) error
	// 録画 mp4 ストリーム
	// (GET /streams/recorded/{videoFileId}/mp4)
	GetStreamsRecordedVideoFileIdMp4(ctx echo.Context, videoFileId PathVideoFileId, params GetStreamsRecordedVideoFileIdMp4Params) error
	// 録画 WebM ストリーム
	// (GET /streams/recorded/{videoFileId}/webm)
	GetStreamsRecordedVideoFileIdWebm(ctx echo.Context, videoFileId PathVideoFileId, params GetStreamsRecordedVideoFileIdWebmParams) error
	// ストリームを停止
	// (DELETE /streams/{streamId})
	DeleteStreamsStreamId(ctx echo.Context, streamId PathStreamId) error
	// ストリーム停止タイマーを更新する
	// (PUT /streams/{streamId}/keep)
	PutStreamsStreamIdKeep(ctx echo.Context, streamId PathStreamId) error
	// タグ情報取得
	// (GET /tags)
	GetTags(ctx echo.Context, params GetTagsParams) error
	// タグ追加
	// (POST /tags)
	PostTags(ctx echo.Context) error
	// タグ削除
	// (DELETE /tags/{tagId})
	DeleteTagsTagId(ctx echo.Context, tagId PathRecordedTagId) error
	// タグ名変更
	// (PUT /tags/{tagId})
	PutTagsTagId(ctx echo.Context, tagId PathRecordedTagId) error
	// 録画番組とタグの関連付けを削除
	// (DELETE /tags/{tagId}/relate)
	DeleteTagsTagIdRelate(ctx echo.Context, tagId PathRecordedTagId, params DeleteTagsTagIdRelateParams) error
	// 録画番組とタグを関連付ける
	// (PUT /tags/{tagId}/relate)
	PutTagsTagIdRelate(ctx echo.Context, tagId PathRecordedTagId) error
	// サムネイル再生成
	// (POST /thumbnails)
	PostThumbnails(ctx echo.Context) error
	// サムネイルをクリーンアップ
	// (POST /thumbnails/cleanup)
	PostThumbnailsCleanup(ctx echo.Context) error
	// サムネイル
	// (GET /thumbnails/{thumbnailId})
	GetThumbnailsThumbnailId(ctx echo.Context, thumbnailId PathThumbnailId) error
	// バージョン情報取得
	// (GET /version)
	GetVersion(ctx echo.Context) error
	// アップロードしたビデオファイルを追加
	// (POST /videos/upload)
	PostVideosUpload(ctx echo.Context) error
	// ビデオファイル
	// (DELETE /videos/{videoFileId})
	DeleteVideosVideoFileId(ctx echo.Context, videoFileId PathVideoFileId) error
	// ビデオファイル
	// (GET /videos/{videoFileId})
	GetVideosVideoFileId(ctx echo.Context, videoFileId PathVideoFileId, params GetVideosVideoFileIdParams) error
	// 動画の長さ
	// (GET /videos/{videoFileId}/duration)
	GetVideosVideoFileIdDuration(ctx echo.Context, videoFileId PathVideoFileId) error
	// ビデオリンクを kodi へ送信
	// (POST /videos/{videoFileId}/kodi)
	PostVideosVideoFileIdKodi(ctx echo.Context, videoFileId PathVideoFileId) error
	// ビデオプレイリスト
	// (GET /videos/{videoFileId}/playlist)
	GetVideosVideoFileIdPlaylist(ctx echo.Context, videoFileId PathVideoFileId) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// GetChannels converts echo context to params.
func (w *ServerInterfaceWrapper) GetChannels(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetChannels(ctx)
	return err
}

// GetChannelsChannelIdLogo converts echo context to params.
func (w *ServerInterfaceWrapper) GetChannelsChannelIdLogo(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "channelId" -------------
	var channelId PathChannelId

	err = runtime.BindStyledParameterWithOptions("simple", "channelId", ctx.Param("channelId"), &channelId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter channelId: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetChannelsChannelIdLogo(ctx, channelId)
	return err
}

// GetConfig converts echo context to params.
func (w *ServerInterfaceWrapper) GetConfig(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetConfig(ctx)
	return err
}

// GetDropLogsDropLogFileId converts echo context to params.
func (w *ServerInterfaceWrapper) GetDropLogsDropLogFileId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "dropLogFileId" -------------
	var dropLogFileId PathDropLogFileId

	err = runtime.BindStyledParameterWithOptions("simple", "dropLogFileId", ctx.Param("dropLogFileId"), &dropLogFileId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter dropLogFileId: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetDropLogsDropLogFileIdParams
	// ------------- Optional query parameter "maxsize" -------------

	err = runtime.BindQueryParameter("form", true, false, "maxsize", ctx.QueryParams(), &params.Maxsize)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter maxsize: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetDropLogsDropLogFileId(ctx, dropLogFileId, params)
	return err
}

// GetEncode converts echo context to params.
func (w *ServerInterfaceWrapper) GetEncode(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetEncodeParams
	// ------------- Required query parameter "isHalfWidth" -------------

	err = runtime.BindQueryParameter("form", true, true, "isHalfWidth", ctx.QueryParams(), &params.IsHalfWidth)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter isHalfWidth: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetEncode(ctx, params)
	return err
}

// PostEncode converts echo context to params.
func (w *ServerInterfaceWrapper) PostEncode(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostEncode(ctx)
	return err
}

// DeleteEncodeEncodeId converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteEncodeEncodeId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "encodeId" -------------
	var encodeId PathEncodeId

	err = runtime.BindStyledParameterWithOptions("simple", "encodeId", ctx.Param("encodeId"), &encodeId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter encodeId: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteEncodeEncodeId(ctx, encodeId)
	return err
}

// GetIptvChannelM3u8 converts echo context to params.
func (w *ServerInterfaceWrapper) GetIptvChannelM3u8(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetIptvChannelM3u8Params
	// ------------- Optional query parameter "isHalfWidth" -------------

	err = runtime.BindQueryParameter("form", true, false, "isHalfWidth", ctx.QueryParams(), &params.IsHalfWidth)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter isHalfWidth: %s", err))
	}

	// ------------- Required query parameter "mode" -------------

	err = runtime.BindQueryParameter("form", true, true, "mode", ctx.QueryParams(), &params.Mode)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter mode: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetIptvChannelM3u8(ctx, params)
	return err
}

// GetIptvEpgXml converts echo context to params.
func (w *ServerInterfaceWrapper) GetIptvEpgXml(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetIptvEpgXmlParams
	// ------------- Optional query parameter "isHalfWidth" -------------

	err = runtime.BindQueryParameter("form", true, false, "isHalfWidth", ctx.QueryParams(), &params.IsHalfWidth)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter isHalfWidth: %s", err))
	}

	// ------------- Optional query parameter "days" -------------

	err = runtime.BindQueryParameter("form", true, false, "days", ctx.QueryParams(), &params.Days)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter days: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetIptvEpgXml(ctx, params)
	return err
}

// GetRecorded converts echo context to params.
func (w *ServerInterfaceWrapper) GetRecorded(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetRecordedParams
	// ------------- Required query parameter "isHalfWidth" -------------

	err = runtime.BindQueryParameter("form", true, true, "isHalfWidth", ctx.QueryParams(), &params.IsHalfWidth)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter isHalfWidth: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "isReverse" -------------

	err = runtime.BindQueryParameter("form", true, false, "isReverse", ctx.QueryParams(), &params.IsReverse)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter isReverse: %s", err))
	}

	// ------------- Optional query parameter "ruleId" -------------

	err = runtime.BindQueryParameter("form", true, false, "ruleId", ctx.QueryParams(), &params.RuleId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ruleId: %s", err))
	}

	// ------------- Optional query parameter "channelId" -------------

	err = runtime.BindQueryParameter("form", true, false, "channelId", ctx.QueryParams(), &params.ChannelId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter channelId: %s", err))
	}

	// ------------- Optional query parameter "genre" -------------

	err = runtime.BindQueryParameter("form", true, false, "genre", ctx.QueryParams(), &params.Genre)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter genre: %s", err))
	}

	// ------------- Optional query parameter "keyword" -------------

	err = runtime.BindQueryParameter("form", true, false, "keyword", ctx.QueryParams(), &params.Keyword)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter keyword: %s", err))
	}

	// ------------- Optional query parameter "hasOriginalFile" -------------

	err = runtime.BindQueryParameter("form", true, false, "hasOriginalFile", ctx.QueryParams(), &params.HasOriginalFile)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hasOriginalFile: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetRecorded(ctx, params)
	return err
}

// PostRecorded converts echo context to params.
func (w *ServerInterfaceWrapper) PostRecorded(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostRecorded(ctx)
	return err
}

// PostRecordedCleanup converts echo context to params.
func (w *ServerInterfaceWrapper) PostRecordedCleanup(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostRecordedCleanup(ctx)
	return err
}

// GetRecordedOptions converts echo context to params.
func (w *ServerInterfaceWrapper) GetRecordedOptions(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetRecordedOptions(ctx)
	return err
}

// DeleteRecordedRecordedId converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteRecordedRecordedId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "recordedId" -------------
	var recordedId PathRecordedId

	err = runtime.BindStyledParameterWithOptions("simple", "recordedId", ctx.Param("recordedId"), &recordedId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter recordedId: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteRecordedRecordedId(ctx, recordedId)
	return err
}

// GetRecordedRecordedId converts echo context to params.
func (w *ServerInterfaceWrapper) GetRecordedRecordedId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "recordedId" -------------
	var recordedId PathRecordedId

	err = runtime.BindStyledParameterWithOptions("simple", "recordedId", ctx.Param("recordedId"), &recordedId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter recordedId: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetRecordedRecordedIdParams
	// ------------- Required query parameter "isHalfWidth" -------------

	err = runtime.BindQueryParameter("form", true, true, "isHalfWidth", ctx.QueryParams(), &params.IsHalfWidth)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter isHalfWidth: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetRecordedRecordedId(ctx, recordedId, params)
	return err
}

// DeleteRecordedRecordedIdEncode converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteRecordedRecordedIdEncode(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "recordedId" -------------
	var recordedId PathRecordedId

	err = runtime.BindStyledParameterWithOptions("simple", "recordedId", ctx.Param("recordedId"), &recordedId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter recordedId: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteRecordedRecordedIdEncode(ctx, recordedId)
	return err
}

// PutRecordedRecordedIdProtect converts echo context to params.
func (w *ServerInterfaceWrapper) PutRecordedRecordedIdProtect(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "recordedId" -------------
	var recordedId PathRecordedId

	err = runtime.BindStyledParameterWithOptions("simple", "recordedId", ctx.Param("recordedId"), &recordedId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter recordedId: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PutRecordedRecordedIdProtect(ctx, recordedId)
	return err
}

// PutRecordedRecordedIdUnprotect converts echo context to params.
func (w *ServerInterfaceWrapper) PutRecordedRecordedIdUnprotect(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "recordedId" -------------
	var recordedId PathRecordedId

	err = runtime.BindStyledParameterWithOptions("simple", "recordedId", ctx.Param("recordedId"), &recordedId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter recordedId: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PutRecordedRecordedIdUnprotect(ctx, recordedId)
	return err
}

// GetRecording converts echo context to params.
func (w *ServerInterfaceWrapper) GetRecording(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetRecordingParams
	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Required query parameter "isHalfWidth" -------------

	err = runtime.BindQueryParameter("form", true, true, "isHalfWidth", ctx.QueryParams(), &params.IsHalfWidth)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter isHalfWidth: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetRecording(ctx, params)
	return err
}

// PostRecordingResettimer converts echo context to params.
func (w *ServerInterfaceWrapper) PostRecordingResettimer(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostRecordingResettimer(ctx)
	return err
}

// GetReserves converts echo context to params.
func (w *ServerInterfaceWrapper) GetReserves(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetReservesParams
	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "type" -------------

	err = runtime.BindQueryParameter("form", true, false, "type", ctx.QueryParams(), &params.Type)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter type: %s", err))
	}

	// ------------- Required query parameter "isHalfWidth" -------------

	err = runtime.BindQueryParameter("form", true, true, "isHalfWidth", ctx.QueryParams(), &params.IsHalfWidth)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter isHalfWidth: %s", err))
	}

	// ------------- Optional query parameter "ruleId" -------------

	err = runtime.BindQueryParameter("form", true, false, "ruleId", ctx.QueryParams(), &params.RuleId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ruleId: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetReserves(ctx, params)
	return err
}

// PostReserves converts echo context to params.
func (w *ServerInterfaceWrapper) PostReserves(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostReserves(ctx)
	return err
}

// GetReservesCnts converts echo context to params.
func (w *ServerInterfaceWrapper) GetReservesCnts(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetReservesCnts(ctx)
	return err
}

// GetReservesLists converts echo context to params.
func (w *ServerInterfaceWrapper) GetReservesLists(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetReservesListsParams
	// ------------- Required query parameter "startAt" -------------

	err = runtime.BindQueryParameter("form", true, true, "startAt", ctx.QueryParams(), &params.StartAt)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter startAt: %s", err))
	}

	// ------------- Required query parameter "endAt" -------------

	err = runtime.BindQueryParameter("form", true, true, "endAt", ctx.QueryParams(), &params.EndAt)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter endAt: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetReservesLists(ctx, params)
	return err
}

// PostReservesUpdate converts echo context to params.
func (w *ServerInterfaceWrapper) PostReservesUpdate(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostReservesUpdate(ctx)
	return err
}

// DeleteReservesReserveId converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteReservesReserveId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "reserveId" -------------
	var reserveId PathReserveId

	err = runtime.BindStyledParameterWithOptions("simple", "reserveId", ctx.Param("reserveId"), &reserveId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter reserveId: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteReservesReserveId(ctx, reserveId)
	return err
}

// GetReservesReserveId converts echo context to params.
func (w *ServerInterfaceWrapper) GetReservesReserveId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "reserveId" -------------
	var reserveId PathReserveId

	err = runtime.BindStyledParameterWithOptions("simple", "reserveId", ctx.Param("reserveId"), &reserveId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter reserveId: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetReservesReserveIdParams
	// ------------- Required query parameter "isHalfWidth" -------------

	err = runtime.BindQueryParameter("form", true, true, "isHalfWidth", ctx.QueryParams(), &params.IsHalfWidth)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter isHalfWidth: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetReservesReserveId(ctx, reserveId, params)
	return err
}

// PutReservesReserveId converts echo context to params.
func (w *ServerInterfaceWrapper) PutReservesReserveId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "reserveId" -------------
	var reserveId PathReserveId

	err = runtime.BindStyledParameterWithOptions("simple", "reserveId", ctx.Param("reserveId"), &reserveId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter reserveId: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PutReservesReserveId(ctx, reserveId)
	return err
}

// DeleteReservesReserveIdOverlap converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteReservesReserveIdOverlap(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "reserveId" -------------
	var reserveId PathReserveId

	err = runtime.BindStyledParameterWithOptions("simple", "reserveId", ctx.Param("reserveId"), &reserveId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter reserveId: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteReservesReserveIdOverlap(ctx, reserveId)
	return err
}

// DeleteReservesReserveIdSkip converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteReservesReserveIdSkip(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "reserveId" -------------
	var reserveId PathReserveId

	err = runtime.BindStyledParameterWithOptions("simple", "reserveId", ctx.Param("reserveId"), &reserveId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter reserveId: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteReservesReserveIdSkip(ctx, reserveId)
	return err
}

// GetRules converts echo context to params.
func (w *ServerInterfaceWrapper) GetRules(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetRulesParams
	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "type" -------------

	err = runtime.BindQueryParameter("form", true, false, "type", ctx.QueryParams(), &params.Type)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter type: %s", err))
	}

	// ------------- Optional query parameter "keyword" -------------

	err = runtime.BindQueryParameter("form", true, false, "keyword", ctx.QueryParams(), &params.Keyword)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter keyword: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetRules(ctx, params)
	return err
}

// PostRules converts echo context to params.
func (w *ServerInterfaceWrapper) PostRules(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostRules(ctx)
	return err
}

// GetRulesKeyword converts echo context to params.
func (w *ServerInterfaceWrapper) GetRulesKeyword(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetRulesKeywordParams
	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "keyword" -------------

	err = runtime.BindQueryParameter("form", true, false, "keyword", ctx.QueryParams(), &params.Keyword)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter keyword: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetRulesKeyword(ctx, params)
	return err
}

// PostRulesKeyword converts echo context to params.
func (w *ServerInterfaceWrapper) PostRulesKeyword(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostRulesKeyword(ctx)
	return err
}

// DeleteRulesRuleId converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteRulesRuleId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ruleId" -------------
	var ruleId PathRuleId

	err = runtime.BindStyledParameterWithOptions("simple", "ruleId", ctx.Param("ruleId"), &ruleId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ruleId: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteRulesRuleId(ctx, ruleId)
	return err
}

// GetRulesRuleId converts echo context to params.
func (w *ServerInterfaceWrapper) GetRulesRuleId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ruleId" -------------
	var ruleId PathRuleId

	err = runtime.BindStyledParameterWithOptions("simple", "ruleId", ctx.Param("ruleId"), &ruleId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ruleId: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetRulesRuleId(ctx, ruleId)
	return err
}

// PutRulesRuleId converts echo context to params.
func (w *ServerInterfaceWrapper) PutRulesRuleId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ruleId" -------------
	var ruleId PathRuleId

	err = runtime.BindStyledParameterWithOptions("simple", "ruleId", ctx.Param("ruleId"), &ruleId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ruleId: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PutRulesRuleId(ctx, ruleId)
	return err
}

// PutRulesRuleIdDisable converts echo context to params.
func (w *ServerInterfaceWrapper) PutRulesRuleIdDisable(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ruleId" -------------
	var ruleId PathRuleId

	err = runtime.BindStyledParameterWithOptions("simple", "ruleId", ctx.Param("ruleId"), &ruleId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ruleId: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PutRulesRuleIdDisable(ctx, ruleId)
	return err
}

// PutRulesRuleIdEnable converts echo context to params.
func (w *ServerInterfaceWrapper) PutRulesRuleIdEnable(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ruleId" -------------
	var ruleId PathRuleId

	err = runtime.BindStyledParameterWithOptions("simple", "ruleId", ctx.Param("ruleId"), &ruleId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ruleId: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PutRulesRuleIdEnable(ctx, ruleId)
	return err
}

// GetSchedules converts echo context to params.
func (w *ServerInterfaceWrapper) GetSchedules(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetSchedulesParams
	// ------------- Required query parameter "startAt" -------------

	err = runtime.BindQueryParameter("form", true, true, "startAt", ctx.QueryParams(), &params.StartAt)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter startAt: %s", err))
	}

	// ------------- Required query parameter "endAt" -------------

	err = runtime.BindQueryParameter("form", true, true, "endAt", ctx.QueryParams(), &params.EndAt)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter endAt: %s", err))
	}

	// ------------- Required query parameter "isHalfWidth" -------------

	err = runtime.BindQueryParameter("form", true, true, "isHalfWidth", ctx.QueryParams(), &params.IsHalfWidth)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter isHalfWidth: %s", err))
	}

	// ------------- Optional query parameter "needsRawExtended" -------------

	err = runtime.BindQueryParameter("form", true, false, "needsRawExtended", ctx.QueryParams(), &params.NeedsRawExtended)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter needsRawExtended: %s", err))
	}

	// ------------- Optional query parameter "isFree" -------------

	err = runtime.BindQueryParameter("form", true, false, "isFree", ctx.QueryParams(), &params.IsFree)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter isFree: %s", err))
	}

	// ------------- Required query parameter "GR" -------------

	err = runtime.BindQueryParameter("form", true, true, "GR", ctx.QueryParams(), &params.GR)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter GR: %s", err))
	}

	// ------------- Required query parameter "BS" -------------

	err = runtime.BindQueryParameter("form", true, true, "BS", ctx.QueryParams(), &params.BS)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter BS: %s", err))
	}

	// ------------- Required query parameter "CS" -------------

	err = runtime.BindQueryParameter("form", true, true, "CS", ctx.QueryParams(), &params.CS)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter CS: %s", err))
	}

	// ------------- Required query parameter "SKY" -------------

	err = runtime.BindQueryParameter("form", true, true, "SKY", ctx.QueryParams(), &params.SKY)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter SKY: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetSchedules(ctx, params)
	return err
}

// GetSchedulesBroadcasting converts echo context to params.
func (w *ServerInterfaceWrapper) GetSchedulesBroadcasting(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetSchedulesBroadcastingParams
	// ------------- Optional query parameter "time" -------------

	err = runtime.BindQueryParameter("form", true, false, "time", ctx.QueryParams(), &params.Time)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter time: %s", err))
	}

	// ------------- Required query parameter "isHalfWidth" -------------

	err = runtime.BindQueryParameter("form", true, true, "isHalfWidth", ctx.QueryParams(), &params.IsHalfWidth)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter isHalfWidth: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetSchedulesBroadcasting(ctx, params)
	return err
}

// GetSchedulesDetailProgramId converts echo context to params.
func (w *ServerInterfaceWrapper) GetSchedulesDetailProgramId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "programId" -------------
	var programId PathProgramId

	err = runtime.BindStyledParameterWithOptions("simple", "programId", ctx.Param("programId"), &programId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter programId: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetSchedulesDetailProgramIdParams
	// ------------- Required query parameter "isHalfWidth" -------------

	err = runtime.BindQueryParameter("form", true, true, "isHalfWidth", ctx.QueryParams(), &params.IsHalfWidth)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter isHalfWidth: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetSchedulesDetailProgramId(ctx, programId, params)
	return err
}

// PostSchedulesSearch converts echo context to params.
func (w *ServerInterfaceWrapper) PostSchedulesSearch(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostSchedulesSearch(ctx)
	return err
}

// GetSchedulesChannelId converts echo context to params.
func (w *ServerInterfaceWrapper) GetSchedulesChannelId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "channelId" -------------
	var channelId PathChannelId

	err = runtime.BindStyledParameterWithOptions("simple", "channelId", ctx.Param("channelId"), &channelId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter channelId: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetSchedulesChannelIdParams
	// ------------- Required query parameter "startAt" -------------

	err = runtime.BindQueryParameter("form", true, true, "startAt", ctx.QueryParams(), &params.StartAt)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter startAt: %s", err))
	}

	// ------------- Required query parameter "days" -------------

	err = runtime.BindQueryParameter("form", true, true, "days", ctx.QueryParams(), &params.Days)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter days: %s", err))
	}

	// ------------- Required query parameter "isHalfWidth" -------------

	err = runtime.BindQueryParameter("form", true, true, "isHalfWidth", ctx.QueryParams(), &params.IsHalfWidth)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter isHalfWidth: %s", err))
	}

	// ------------- Optional query parameter "needsRawExtended" -------------

	err = runtime.BindQueryParameter("form", true, false, "needsRawExtended", ctx.QueryParams(), &params.NeedsRawExtended)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter needsRawExtended: %s", err))
	}

	// ------------- Optional query parameter "isFree" -------------

	err = runtime.BindQueryParameter("form", true, false, "isFree", ctx.QueryParams(), &params.IsFree)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter isFree: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetSchedulesChannelId(ctx, channelId, params)
	return err
}

// GetStorages converts echo context to params.
func (w *ServerInterfaceWrapper) GetStorages(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetStorages(ctx)
	return err
}

// DeleteStreams converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteStreams(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteStreams(ctx)
	return err
}

// GetStreams converts echo context to params.
func (w *ServerInterfaceWrapper) GetStreams(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetStreamsParams
	// ------------- Required query parameter "isHalfWidth" -------------

	err = runtime.BindQueryParameter("form", true, true, "isHalfWidth", ctx.QueryParams(), &params.IsHalfWidth)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter isHalfWidth: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetStreams(ctx, params)
	return err
}

// GetStreamsLiveChannelIdHls converts echo context to params.
func (w *ServerInterfaceWrapper) GetStreamsLiveChannelIdHls(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "channelId" -------------
	var channelId PathChannelId

	err = runtime.BindStyledParameterWithOptions("simple", "channelId", ctx.Param("channelId"), &channelId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter channelId: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetStreamsLiveChannelIdHlsParams
	// ------------- Required query parameter "mode" -------------

	err = runtime.BindQueryParameter("form", true, true, "mode", ctx.QueryParams(), &params.Mode)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter mode: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetStreamsLiveChannelIdHls(ctx, channelId, params)
	return err
}

// GetStreamsLiveChannelIdM2ts converts echo context to params.
func (w *ServerInterfaceWrapper) GetStreamsLiveChannelIdM2ts(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "channelId" -------------
	var channelId PathChannelId

	err = runtime.BindStyledParameterWithOptions("simple", "channelId", ctx.Param("channelId"), &channelId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter channelId: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetStreamsLiveChannelIdM2tsParams
	// ------------- Required query parameter "mode" -------------

	err = runtime.BindQueryParameter("form", true, true, "mode", ctx.QueryParams(), &params.Mode)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter mode: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetStreamsLiveChannelIdM2ts(ctx, channelId, params)
	return err
}

// GetStreamsLiveChannelIdM2tsPlaylist converts echo context to params.
func (w *ServerInterfaceWrapper) GetStreamsLiveChannelIdM2tsPlaylist(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "channelId" -------------
	var channelId PathChannelId

	err = runtime.BindStyledParameterWithOptions("simple", "channelId", ctx.Param("channelId"), &channelId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter channelId: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetStreamsLiveChannelIdM2tsPlaylistParams
	// ------------- Required query parameter "mode" -------------

	err = runtime.BindQueryParameter("form", true, true, "mode", ctx.QueryParams(), &params.Mode)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter mode: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetStreamsLiveChannelIdM2tsPlaylist(ctx, channelId, params)
	return err
}

// GetStreamsLiveChannelIdM2tsll converts echo context to params.
func (w *ServerInterfaceWrapper) GetStreamsLiveChannelIdM2tsll(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "channelId" -------------
	var channelId PathChannelId

	err = runtime.BindStyledParameterWithOptions("simple", "channelId", ctx.Param("channelId"), &channelId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter channelId: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetStreamsLiveChannelIdM2tsllParams
	// ------------- Required query parameter "mode" -------------

	err = runtime.BindQueryParameter("form", true, true, "mode", ctx.QueryParams(), &params.Mode)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter mode: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetStreamsLiveChannelIdM2tsll(ctx, channelId, params)
	return err
}

// GetStreamsLiveChannelIdMp4 converts echo context to params.
func (w *ServerInterfaceWrapper) GetStreamsLiveChannelIdMp4(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "channelId" -------------
	var channelId PathChannelId

	err = runtime.BindStyledParameterWithOptions("simple", "channelId", ctx.Param("channelId"), &channelId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter channelId: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetStreamsLiveChannelIdMp4Params
	// ------------- Required query parameter "mode" -------------

	err = runtime.BindQueryParameter("form", true, true, "mode", ctx.QueryParams(), &params.Mode)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter mode: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetStreamsLiveChannelIdMp4(ctx, channelId, params)
	return err
}

// GetStreamsLiveChannelIdWebm converts echo context to params.
func (w *ServerInterfaceWrapper) GetStreamsLiveChannelIdWebm(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "channelId" -------------
	var channelId PathChannelId

	err = runtime.BindStyledParameterWithOptions("simple", "channelId", ctx.Param("channelId"), &channelId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter channelId: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetStreamsLiveChannelIdWebmParams
	// ------------- Required query parameter "mode" -------------

	err = runtime.BindQueryParameter("form", true, true, "mode", ctx.QueryParams(), &params.Mode)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter mode: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetStreamsLiveChannelIdWebm(ctx, channelId, params)
	return err
}

// GetStreamsRecordedVideoFileIdHls converts echo context to params.
func (w *ServerInterfaceWrapper) GetStreamsRecordedVideoFileIdHls(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "videoFileId" -------------
	var videoFileId PathVideoFileId

	err = runtime.BindStyledParameterWithOptions("simple", "videoFileId", ctx.Param("videoFileId"), &videoFileId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter videoFileId: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetStreamsRecordedVideoFileIdHlsParams
	// ------------- Required query parameter "ss" -------------

	err = runtime.BindQueryParameter("form", true, true, "ss", ctx.QueryParams(), &params.Ss)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ss: %s", err))
	}

	// ------------- Required query parameter "mode" -------------

	err = runtime.BindQueryParameter("form", true, true, "mode", ctx.QueryParams(), &params.Mode)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter mode: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetStreamsRecordedVideoFileIdHls(ctx, videoFileId, params)
	return err
}

// GetStreamsRecordedVideoFileIdMp4 converts echo context to params.
func (w *ServerInterfaceWrapper) GetStreamsRecordedVideoFileIdMp4(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "videoFileId" -------------
	var videoFileId PathVideoFileId

	err = runtime.BindStyledParameterWithOptions("simple", "videoFileId", ctx.Param("videoFileId"), &videoFileId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter videoFileId: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetStreamsRecordedVideoFileIdMp4Params
	// ------------- Required query parameter "ss" -------------

	err = runtime.BindQueryParameter("form", true, true, "ss", ctx.QueryParams(), &params.Ss)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ss: %s", err))
	}

	// ------------- Required query parameter "mode" -------------

	err = runtime.BindQueryParameter("form", true, true, "mode", ctx.QueryParams(), &params.Mode)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter mode: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetStreamsRecordedVideoFileIdMp4(ctx, videoFileId, params)
	return err
}

// GetStreamsRecordedVideoFileIdWebm converts echo context to params.
func (w *ServerInterfaceWrapper) GetStreamsRecordedVideoFileIdWebm(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "videoFileId" -------------
	var videoFileId PathVideoFileId

	err = runtime.BindStyledParameterWithOptions("simple", "videoFileId", ctx.Param("videoFileId"), &videoFileId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter videoFileId: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetStreamsRecordedVideoFileIdWebmParams
	// ------------- Required query parameter "ss" -------------

	err = runtime.BindQueryParameter("form", true, true, "ss", ctx.QueryParams(), &params.Ss)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ss: %s", err))
	}

	// ------------- Required query parameter "mode" -------------

	err = runtime.BindQueryParameter("form", true, true, "mode", ctx.QueryParams(), &params.Mode)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter mode: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetStreamsRecordedVideoFileIdWebm(ctx, videoFileId, params)
	return err
}

// DeleteStreamsStreamId converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteStreamsStreamId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "streamId" -------------
	var streamId PathStreamId

	err = runtime.BindStyledParameterWithOptions("simple", "streamId", ctx.Param("streamId"), &streamId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter streamId: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteStreamsStreamId(ctx, streamId)
	return err
}

// PutStreamsStreamIdKeep converts echo context to params.
func (w *ServerInterfaceWrapper) PutStreamsStreamIdKeep(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "streamId" -------------
	var streamId PathStreamId

	err = runtime.BindStyledParameterWithOptions("simple", "streamId", ctx.Param("streamId"), &streamId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter streamId: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PutStreamsStreamIdKeep(ctx, streamId)
	return err
}

// GetTags converts echo context to params.
func (w *ServerInterfaceWrapper) GetTags(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTagsParams
	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "excludeTagId" -------------

	err = runtime.BindQueryParameter("form", true, false, "excludeTagId", ctx.QueryParams(), &params.ExcludeTagId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter excludeTagId: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetTags(ctx, params)
	return err
}

// PostTags converts echo context to params.
func (w *ServerInterfaceWrapper) PostTags(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostTags(ctx)
	return err
}

// DeleteTagsTagId converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteTagsTagId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "tagId" -------------
	var tagId PathRecordedTagId

	err = runtime.BindStyledParameterWithOptions("simple", "tagId", ctx.Param("tagId"), &tagId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tagId: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteTagsTagId(ctx, tagId)
	return err
}

// PutTagsTagId converts echo context to params.
func (w *ServerInterfaceWrapper) PutTagsTagId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "tagId" -------------
	var tagId PathRecordedTagId

	err = runtime.BindStyledParameterWithOptions("simple", "tagId", ctx.Param("tagId"), &tagId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tagId: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PutTagsTagId(ctx, tagId)
	return err
}

// DeleteTagsTagIdRelate converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteTagsTagIdRelate(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "tagId" -------------
	var tagId PathRecordedTagId

	err = runtime.BindStyledParameterWithOptions("simple", "tagId", ctx.Param("tagId"), &tagId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tagId: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params DeleteTagsTagIdRelateParams
	// ------------- Optional query parameter "recordedId" -------------

	err = runtime.BindQueryParameter("form", true, false, "recordedId", ctx.QueryParams(), &params.RecordedId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter recordedId: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteTagsTagIdRelate(ctx, tagId, params)
	return err
}

// PutTagsTagIdRelate converts echo context to params.
func (w *ServerInterfaceWrapper) PutTagsTagIdRelate(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "tagId" -------------
	var tagId PathRecordedTagId

	err = runtime.BindStyledParameterWithOptions("simple", "tagId", ctx.Param("tagId"), &tagId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tagId: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PutTagsTagIdRelate(ctx, tagId)
	return err
}

// PostThumbnails converts echo context to params.
func (w *ServerInterfaceWrapper) PostThumbnails(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostThumbnails(ctx)
	return err
}

// PostThumbnailsCleanup converts echo context to params.
func (w *ServerInterfaceWrapper) PostThumbnailsCleanup(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostThumbnailsCleanup(ctx)
	return err
}

// GetThumbnailsThumbnailId converts echo context to params.
func (w *ServerInterfaceWrapper) GetThumbnailsThumbnailId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "thumbnailId" -------------
	var thumbnailId PathThumbnailId

	err = runtime.BindStyledParameterWithOptions("simple", "thumbnailId", ctx.Param("thumbnailId"), &thumbnailId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter thumbnailId: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetThumbnailsThumbnailId(ctx, thumbnailId)
	return err
}

// GetVersion converts echo context to params.
func (w *ServerInterfaceWrapper) GetVersion(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetVersion(ctx)
	return err
}

// PostVideosUpload converts echo context to params.
func (w *ServerInterfaceWrapper) PostVideosUpload(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostVideosUpload(ctx)
	return err
}

// DeleteVideosVideoFileId converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteVideosVideoFileId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "videoFileId" -------------
	var videoFileId PathVideoFileId

	err = runtime.BindStyledParameterWithOptions("simple", "videoFileId", ctx.Param("videoFileId"), &videoFileId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter videoFileId: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteVideosVideoFileId(ctx, videoFileId)
	return err
}

// GetVideosVideoFileId converts echo context to params.
func (w *ServerInterfaceWrapper) GetVideosVideoFileId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "videoFileId" -------------
	var videoFileId PathVideoFileId

	err = runtime.BindStyledParameterWithOptions("simple", "videoFileId", ctx.Param("videoFileId"), &videoFileId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter videoFileId: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetVideosVideoFileIdParams
	// ------------- Optional query parameter "isDownload" -------------

	err = runtime.BindQueryParameter("form", true, false, "isDownload", ctx.QueryParams(), &params.IsDownload)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter isDownload: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetVideosVideoFileId(ctx, videoFileId, params)
	return err
}

// GetVideosVideoFileIdDuration converts echo context to params.
func (w *ServerInterfaceWrapper) GetVideosVideoFileIdDuration(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "videoFileId" -------------
	var videoFileId PathVideoFileId

	err = runtime.BindStyledParameterWithOptions("simple", "videoFileId", ctx.Param("videoFileId"), &videoFileId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter videoFileId: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetVideosVideoFileIdDuration(ctx, videoFileId)
	return err
}

// PostVideosVideoFileIdKodi converts echo context to params.
func (w *ServerInterfaceWrapper) PostVideosVideoFileIdKodi(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "videoFileId" -------------
	var videoFileId PathVideoFileId

	err = runtime.BindStyledParameterWithOptions("simple", "videoFileId", ctx.Param("videoFileId"), &videoFileId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter videoFileId: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostVideosVideoFileIdKodi(ctx, videoFileId)
	return err
}

// GetVideosVideoFileIdPlaylist converts echo context to params.
func (w *ServerInterfaceWrapper) GetVideosVideoFileIdPlaylist(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "videoFileId" -------------
	var videoFileId PathVideoFileId

	err = runtime.BindStyledParameterWithOptions("simple", "videoFileId", ctx.Param("videoFileId"), &videoFileId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter videoFileId: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetVideosVideoFileIdPlaylist(ctx, videoFileId)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/channels", wrapper.GetChannels)
	router.GET(baseURL+"/channels/:channelId/logo", wrapper.GetChannelsChannelIdLogo)
	router.GET(baseURL+"/config", wrapper.GetConfig)
	router.GET(baseURL+"/dropLogs/:dropLogFileId", wrapper.GetDropLogsDropLogFileId)
	router.GET(baseURL+"/encode", wrapper.GetEncode)
	router.POST(baseURL+"/encode", wrapper.PostEncode)
	router.DELETE(baseURL+"/encode/:encodeId", wrapper.DeleteEncodeEncodeId)
	router.GET(baseURL+"/iptv/channel.m3u8", wrapper.GetIptvChannelM3u8)
	router.GET(baseURL+"/iptv/epg.xml", wrapper.GetIptvEpgXml)
	router.GET(baseURL+"/recorded", wrapper.GetRecorded)
	router.POST(baseURL+"/recorded", wrapper.PostRecorded)
	router.POST(baseURL+"/recorded/cleanup", wrapper.PostRecordedCleanup)
	router.GET(baseURL+"/recorded/options", wrapper.GetRecordedOptions)
	router.DELETE(baseURL+"/recorded/:recordedId", wrapper.DeleteRecordedRecordedId)
	router.GET(baseURL+"/recorded/:recordedId", wrapper.GetRecordedRecordedId)
	router.DELETE(baseURL+"/recorded/:recordedId/encode", wrapper.DeleteRecordedRecordedIdEncode)
	router.PUT(baseURL+"/recorded/:recordedId/protect", wrapper.PutRecordedRecordedIdProtect)
	router.PUT(baseURL+"/recorded/:recordedId/unprotect", wrapper.PutRecordedRecordedIdUnprotect)
	router.GET(baseURL+"/recording", wrapper.GetRecording)
	router.POST(baseURL+"/recording/resettimer", wrapper.PostRecordingResettimer)
	router.GET(baseURL+"/reserves", wrapper.GetReserves)
	router.POST(baseURL+"/reserves", wrapper.PostReserves)
	router.GET(baseURL+"/reserves/cnts", wrapper.GetReservesCnts)
	router.GET(baseURL+"/reserves/lists", wrapper.GetReservesLists)
	router.POST(baseURL+"/reserves/update", wrapper.PostReservesUpdate)
	router.DELETE(baseURL+"/reserves/:reserveId", wrapper.DeleteReservesReserveId)
	router.GET(baseURL+"/reserves/:reserveId", wrapper.GetReservesReserveId)
	router.PUT(baseURL+"/reserves/:reserveId", wrapper.PutReservesReserveId)
	router.DELETE(baseURL+"/reserves/:reserveId/overlap", wrapper.DeleteReservesReserveIdOverlap)
	router.DELETE(baseURL+"/reserves/:reserveId/skip", wrapper.DeleteReservesReserveIdSkip)
	router.GET(baseURL+"/rules", wrapper.GetRules)
	router.POST(baseURL+"/rules", wrapper.PostRules)
	router.GET(baseURL+"/rules/keyword", wrapper.GetRulesKeyword)
	router.POST(baseURL+"/rules/keyword", wrapper.PostRulesKeyword)
	router.DELETE(baseURL+"/rules/:ruleId", wrapper.DeleteRulesRuleId)
	router.GET(baseURL+"/rules/:ruleId", wrapper.GetRulesRuleId)
	router.PUT(baseURL+"/rules/:ruleId", wrapper.PutRulesRuleId)
	router.PUT(baseURL+"/rules/:ruleId/disable", wrapper.PutRulesRuleIdDisable)
	router.PUT(baseURL+"/rules/:ruleId/enable", wrapper.PutRulesRuleIdEnable)
	router.GET(baseURL+"/schedules", wrapper.GetSchedules)
	router.GET(baseURL+"/schedules/broadcasting", wrapper.GetSchedulesBroadcasting)
	router.GET(baseURL+"/schedules/detail/:programId", wrapper.GetSchedulesDetailProgramId)
	router.POST(baseURL+"/schedules/search", wrapper.PostSchedulesSearch)
	router.GET(baseURL+"/schedules/:channelId", wrapper.GetSchedulesChannelId)
	router.GET(baseURL+"/storages", wrapper.GetStorages)
	router.DELETE(baseURL+"/streams", wrapper.DeleteStreams)
	router.GET(baseURL+"/streams", wrapper.GetStreams)
	router.GET(baseURL+"/streams/live/:channelId/hls", wrapper.GetStreamsLiveChannelIdHls)
	router.GET(baseURL+"/streams/live/:channelId/m2ts", wrapper.GetStreamsLiveChannelIdM2ts)
	router.GET(baseURL+"/streams/live/:channelId/m2ts/playlist", wrapper.GetStreamsLiveChannelIdM2tsPlaylist)
	router.GET(baseURL+"/streams/live/:channelId/m2tsll", wrapper.GetStreamsLiveChannelIdM2tsll)
	router.GET(baseURL+"/streams/live/:channelId/mp4", wrapper.GetStreamsLiveChannelIdMp4)
	router.GET(baseURL+"/streams/live/:channelId/webm", wrapper.GetStreamsLiveChannelIdWebm)
	router.GET(baseURL+"/streams/recorded/:videoFileId/hls", wrapper.GetStreamsRecordedVideoFileIdHls)
	router.GET(baseURL+"/streams/recorded/:videoFileId/mp4", wrapper.GetStreamsRecordedVideoFileIdMp4)
	router.GET(baseURL+"/streams/recorded/:videoFileId/webm", wrapper.GetStreamsRecordedVideoFileIdWebm)
	router.DELETE(baseURL+"/streams/:streamId", wrapper.DeleteStreamsStreamId)
	router.PUT(baseURL+"/streams/:streamId/keep", wrapper.PutStreamsStreamIdKeep)
	router.GET(baseURL+"/tags", wrapper.GetTags)
	router.POST(baseURL+"/tags", wrapper.PostTags)
	router.DELETE(baseURL+"/tags/:tagId", wrapper.DeleteTagsTagId)
	router.PUT(baseURL+"/tags/:tagId", wrapper.PutTagsTagId)
	router.DELETE(baseURL+"/tags/:tagId/relate", wrapper.DeleteTagsTagIdRelate)
	router.PUT(baseURL+"/tags/:tagId/relate", wrapper.PutTagsTagIdRelate)
	router.POST(baseURL+"/thumbnails", wrapper.PostThumbnails)
	router.POST(baseURL+"/thumbnails/cleanup", wrapper.PostThumbnailsCleanup)
	router.GET(baseURL+"/thumbnails/:thumbnailId", wrapper.GetThumbnailsThumbnailId)
	router.GET(baseURL+"/version", wrapper.GetVersion)
	router.POST(baseURL+"/videos/upload", wrapper.PostVideosUpload)
	router.DELETE(baseURL+"/videos/:videoFileId", wrapper.DeleteVideosVideoFileId)
	router.GET(baseURL+"/videos/:videoFileId", wrapper.GetVideosVideoFileId)
	router.GET(baseURL+"/videos/:videoFileId/duration", wrapper.GetVideosVideoFileIdDuration)
	router.POST(baseURL+"/videos/:videoFileId/kodi", wrapper.PostVideosVideoFileIdKodi)
	router.GET(baseURL+"/videos/:videoFileId/playlist", wrapper.GetVideosVideoFileIdPlaylist)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/+x973fURrLov6Iz732AdyaMPTh5Of6WYBI4McTX4yTvnj18kEftsWKNNFfSGHw53INm",
	"En77wnoxhA13+RECDiyG3ZANgQT/MfLM2P/FO+pWS61Rd6ulmTEzu/lC4pHUVV1VXV1VXV11Olc2qjVD",
	"B7pt5SZP52qyKVeBDUz41weKYquGPqdWgfenAqyyqda8n3KTuZ2t31qX7rZvNXZv/EnaV7X25/I51Xvw",
	"H3VgruTyOV32PsvZ3tf5nFVeBFXZG+Z/m2AhN5n7X4UQdAE9tQqf6eop74NjpdyZM/nclLxixSG3rt5o",
	"vbnZvvl9e/05A6jifZjPmeA/6qoJlNykbdYBiYS9UvPeU3UbVIAJgR3WlQ/sOLTOT43tV+fatxqtC68Z",
	"0AD8kgcuxZw/BvYssIC5DOYgjt34bL+60HnxVbv5devu3xAl3MaW23jgNm+yOOCNQ2ID9Ho1N/mHnKxp",
	"3luGWZW9/ykb+oKmlr2ZWEtqLZfPGcvA1ORa7oSH2NGZuc97ZUiIgwIW5Lpm5yYP5mnM8IAdtY7I2sIX",
	"qmIvUmCuXtp5tNa+cb719KbrPPIp4dxyG5dd5zIDC5UYkYoM4puPz7xhaEDWET7WlHFS1wxZiaPiNtfd",
	"xj3IgiduY81tnnUbD93mj27zqdv81W1eTEYrGJwio1E0PjIBmDGNiilXKbL61b32jVvt6292zzqus+k6",
	"W110kfZ5M5yUyBfz0oKsWWBSat++SPzovXLlfGvzz5NS6+sN13m4n4m9h1My5oNlZuJSjyIzC5aBaVGW",
	"1+7Zc7t3z6VAAo+UAHJaraoU7aLBn+lj42cUOS1O5HNVVVer3kIeo66gaaPykaqBY/KpkvqfgC+17dtn",
	"Ww8euY2fvD8br6R9Sx+u2IDF8Kp8yvKGpGL27ngxEbXjACjWrHzy8Ckb6AqgLCkzfCi5zpXW1tc7Dx02",
	"F/TuAROY8enCggUo3DDQ73QgwUPKrMcS5zwj24uHFmVdB9pRyoTRqmv97aykKhh+TYaS7YMvBx9n3WhC",
	"8BihKdOo+XJCQ0oxjZqkGRVpQdUAEzElMkjKTdfD4rBeNhQqAm5jw9OjjR+RHmWiAPAIGaD7ypQGvoYe",
	"McHWgk+zsiQEjtGZBWXDVIBCw8f0nzERMsOPM1ACg56TK1zotlxhYmDDbzMBhzYPDTCyeNhzxh9mgVqn",
	"S763k3si94QJtZ5V2ku2Ceji5jZ+cZsX3OZjCPouk8YWHiGr1AUoYJzmFuvVeV1WqarJxg/ZTCc+z0CR",
	"z1UFGCwdtOw95CugZeL7lOD/zVPxKdVy17ZA6uUsehiicPhUWasrIGEF7t560HpwA5kkUvRdhmOChsWv",
	"hOipNqhaBE0s21T1Su5MsHXJpimvhPgdka1PTbWi6rLmEZomu489wW28dJuX4OKJmMSta0/cxln2/r3Y",
	"NXzC9g1R+gSsnDRM6jJCZvcztGkwQC75n1NAYWJgSMdlmv8Lx2GYI3IViAzsa/+PgW5SSfrSbX4H/Ygn",
	"DEAV+GXKzQaCm14eD/FIued0IRHZdMQwIQCGSIir4m4EsC4WBI5e9wCXbNm0aU7/7o3LrUeXuU6/5X/b",
	"J7cf6eRjhgKSNoY70CR6vrPxtLX5Z5aJ7o2TUhciDGY0eWXGsFQEOuaonVvtXL+z/dtq57dNFl1SB17w",
	"yx+W4gA/LDHAwAepnD788iEKmEMsMIcyg/l4Ng7m41kGGPggE5jSJ/8eh+P9SAeEnqSAdAY/xRHBY7Je",
	"lzVks/sa5dMaXVq6zPf2xcuty+tB3NB1NuGucdNt/Ow2H7nNH3N5z6SuAdNWAQozqSYo24a5Qgk/Pnzs",
	"Ns+7je/c5l/dxjO0PrZff7/98rI3cOxRsFxiO55qleRlUJKrYIoNzm385k3CW4h/goM/jmxxzkbr2hXX",
	"+aZ190X74lnXebK99T+tp9+Q0YNuyubRIk0imkcfb2N97TabbvNC69qqVDb0BbUiIadHcp1Nyd9wYlOr",
	"ySbQ7SnVFKQfMXqg9/H4eYlCKM85R+Ej773W3Retaxdc51lr6+vduxdoGJmRrUZ0j/C+qxrLABsJFMX0",
	"dbPb5rh4affWAz4HLKNulkGX/clDinyVXIW5yT907YOxkfOhUo5M5USAmDH/JSjbHl4fKAph3rGW1+6V",
	"v3euv4bR3+doVXEXU9nQDJogXPw7jVE61ehBwFrXVuOfdFHDF0kElDXHugaYugNv+wIzQyshHIkvVtBd",
	"RPpL8b+BWmBOrYJSDZTVBbUs05FCBgEKiyKvlCVZvlcqiFNdA7ORDzzZlJfTTakkRz4HslleFIdfIt/v",
	"ZiaNOF0guqfMYDlQEOUT9Z6/TVy41rp0p7V1u/P0uqeuPBW8xeB/8uoNAk3d8wsGYGJNLEfWqkiDsY0d",
	"PBENiNy3bpzREByEITeY50dCaJpkUEZABKlaET9ho1qnepRRBSCIcF1EixMeQARV9DMNT/EQQVU+hcLA",
	"77377sF34T/xeHA4oA2qtKk72PNbdZtP0FlfXJ+jIahevP8MnyAKRCPgq2fyuUV8pkL3eoPZtq6t7kPH",
	"Nvtp28eibE0bFWNKtmXa/J66jRcBF93GWvuK4zrfuc5D1/mKs1+rSorYCmsPI6dA3fmAfdIwl5LF6Hjw",
	"ItS35rJaFhC+UvBiTMtCwyF4TGKSx/tplD3ImLDBIUO3TUP7BKzAd0niR2Uh+Ct3IiqEViQqJEJhT3Jj",
	"8aJgTPrZNSJ9+8f75JE1Po2GPhB066DT5XkqJyjsOQTtU5oS/hGumHXPpm08jy2XedOQlbJsUbz99u2L",
	"rUu/uM7jAD/GkkMealwuDzF+Rz5g/HffaeO4dYkECXUTENtQ3eb9MCAmGP7zzKLDujyvYXsJb0koVsAy",
	"SdsvL7jOFvTvog4g+j3iOG1SgxuucwUzhaEJfLym1WXAQsZt/gCh3Nh5eGPHeSE85lwp5TSluZLUl1kt",
	"GYp6xLBsSo6F90hahM/S8A87JRShh1Zs6+qzneZvrvPYdyZoLmEqgJZRXgL20U9nDJOy0tDTA6oh7Z79",
	"8/bWPdd5tP3bVuf6hu+nNf8H0otwHYk9E517sNc/L0gWXceaugw48pJmqEXN4owkHZkuSQnhO2HSVos2",
	"F9ax4pwwMJ6G98bxg4GyKVdZqGhaIjLTxklpWraBXl6R9lVroGJbB760pM71jf39o0ptgovHzETfQJ0E",
	"8zw1I30B5o/1CdgZiqJnr+WIPkohvGjrUNihhYzqO81aEQfV38VEE5sUuAxerlIgM2DBsy2+yInuf+nF",
	"gjn+XskCG4G9EgA2BgPlusgv+Vzd1OCuQdlNP5udlkrwmcSwphUio5J7UjY7jQY6qi8Y5EaY6iOYJZDy",
	"qy6DHMLFI+VD/E/QaEV+GDGK8oQrQij1wJAnqUo1dDmWapLBTo1tmEC2wXFwEr/LCsm2bzzfeXjVj8dC",
	"ew1JaGf9ceenr/hRiqPpPPcI4FiWK4S388OPnRfPaQ48wIncosev+RxgZiL6k7t8r/XrTzRg8Ah+PPXR",
	"u/9hMeuHBzN8SA+HoAkyYiHp4mn54FA8FfGt+vzHGahYJL8t9vDtwdTfdi3vSApQkBaAbwVAsrMXnkKs",
	"PNYeQK4w19lEC3H7t9vtC9dEA7lZjt3YB1y06RDJpDQj+SJMh2/C88ynnjNM5h8zNgjTqB3S7YTRGk9w",
	"uj3dbQSmaZj0YTzb6gdIsoQxkgOP0VRaeGpuytV5TdUrDNi/QB/7Bwj1Bjyz5CJBCxYGU8sHtOoGnMAp",
	"esYNj1cozB0n0WFFtVFuwGz32VfXNgLTANAxROfnjd1vzyWlAciaZpw8rCvTcnmJFr170nr+pnXhvNu4",
	"4jbWdjb+5m1OjAhLP44KezyZs+WKeLS16wyIYreRQhEhFI3zKVOtKVxGA3jWUWK6B31Rm3VdV/VKuqBz",
	"JN2EFXo+Kat234eNnRER2JMg2dQmhxfK9kAr7ge3eZdBQjXFSWc+pxkVxhEM1XoSykphmAs1YJYBTdvt",
	"nv17e/Vm+Iler84jgSKDGkL7EuQSTRkG6RX+gFSOeAoTXnTsSo2gzfnI3NwMdK/O4XOqXwIC5PK5BcOs",
	"yjZaHgeL7K2H4twiNGjEB5YlVwBvq2re8zRz4zXE6SUjD0NWPtW1FZzeFbFVEJUwIBqRBPJRGZ58BX+Z",
	"0jLFllivhhiCT5tTd0wzNjvvhdZv91u/XqWH7pt/hPS/xzCwVOszvWzoy8C0qV7EV/daDy62r37L2pfo",
	"tvnOvY3Og1cp0m2iaFAJQd+iZU37dCE3+YcEtcLY48+cyHM2+aTtvUbewBG8LZOH94r9jBSOy0ok7CSh",
	"kc1TzeBsZnCSUjgcJ4QCN8fJQ+6uxHb0KFU6g8+ZD+qKapTkas2zPmdlm+luQl786p82NR67jZ+gXoGp",
	"jv56+2twEuQfEI+/NzY2li8Wx94dyxcnvP8/WPT+nZgY9/59f2xs7AQHt0DfJCXaJ41QpI3wEzw2Ehsn",
	"8aoZhehJlIeZhrPAMrQ6L2gSZK/uPPqu1bzaevWQOIAvTozVcvncxPtjKvqP99f/LcL/jI+hX73/en8X",
	"x99DLx/0ntPO6UnE6NkAXSjhvfU83N+eEYhVa6DibbCLB4rvTfj/fZcKFFsJ/hKdVi2bbncR6a1XYPLJ",
	"AylYVBJMIH6M9oE+qYky1SpCAd7158nuXhm6diFsmmrHk0dymmbqcN9MmHbaCeQzWgPUibM3dt7dFTKA",
	"joSN5dZErEuBIEzcRfU03yE8PSzvcUAyTUMK0CeuWc/k30Zs1b/smyIa8ntElv2hmjILXrWgY+dNNMlD",
	"2375lJ3nMmMaNihTLdWd849bl9eRxKMU+tazNzt/uwcvHrLGQ1hS0UIjcbDJEJXOZjCavIIDpFBJ+46p",
	"prxUN+s6vP2ARZFIdCQO5X+PkNO/zRrmokV2ggvG4iOSV5opI8IzPAF9HdwtFoccXPpgwo3aaQJ07bbu",
	"8EAlnBFl+1EXxgRE8oBj9ho9PZV+vBFVAhFFFdU3vC2cvIJgidgt7Qe3Oy/ud/l1/HPI9CLZbUpSmAr1",
	"f/qRo3ZaUuQxmEAAj0dLzj0FFoFSXQ9SldSR615vFKlEGjT7WlHSFXq4HYUlLNim4Jyvv9h3rhiE7Kvi",
	"M2zabTd8eHJ1+/U/hNwHiBMejk02dh4OI5YffpVqtqyFxJiub3+LTxfjxZ+xJttA+Jqd76w6G4j3rrO5",
	"e+P+7tnvtl9/4zp/TIot7cX5qx+SO6TT0rVwJC5yxNitAFD5N8rXnSf/aF274N8cYnh7fhk5Suj/z62X",
	"L/nf+nXmaOJ3fnXnwXn+19aSWsuEdHcMtbsQnpXDgxMockgfPSlk8iB64iN6BXpcPMN/PJ7GTfXl8NBF",
	"8aGLKYc+KD70QbGh0QnuDL7ZjMAcl6sgDYGot59TQUtDs96hpSGjMDTVmgIasIOryB8s2MAUvJ7ZenPF",
	"dZ5ItiUJXrWuGkoqDrGOJtPQnTVGGmommyUcKp4IdQO7sBXbEEEfUkNSvgXADUl1ZU3EeTK6QSu2wqE+",
	"RetqKqJKk14qirx0kE4w9NYxLPK8F4pJL3BBsNRgSj2WUhH1O+Pynz2EF9yN9nTuIVxll7okE3Qy7YNP",
	"/SK9jMelJZX5bI48Q6W/hL02dm2RUDjo7/UjWMe8C/ORn4Rx+vfc1YFH5voQSRvhyJe/kiJLmFx++eiG",
	"G19e/MWdz5pF7KsX9nmf73bgkz2P631KwchSHiLfY40GbjkJghZMHzgvoTKKeQn5lnkJOYqusykFoyec",
	"hZKessC8yRhf6Can/JD0kVN+GjjIqb7rt3dcktk5wYg1ftGs7EXB/AGEvB/G/hWrkpVmzPiuxK653bq2",
	"Cv9ESX1/QeW9qN4Gi6AWvzkAq5pLGt0feiADDE4GeHHDdX6RGLFEtWhxqXh6WlBcJkNubWgxYMSpCf6+",
	"SAvSQFWYs+YWxWQ6j3UN+BVSGcnaeISucqnoTKXz07X2X27HiZMqu5rEQeSEQ2UmUnePFEvgTcO1pbBw",
	"rMCBA36bhVbCZYeAzGKpkGlvOrSuPuOHXeRlQ1Wm6jVNLVPT8boqWaAtEeforbX/ey0xsAPgdUOegCVV",
	"vagBUzWUOeODJFwhcm5jbdfD9Y9u43L79p3dG3+iLoAB3rLwZxwz+LpozZKYUldlNgbZqIebjIo0lJqp",
	"rCI1lLqnrLo1lNqlzFI2tPqj8ZcDE9filGUSLVMRiQ91703cJKf2w8bOQ0fah0kcUYD7qZgrdROWvTsm",
	"n2Imj8AmGrghUuvCuf1UwQxGUnXeSM+vJo7ETpFC+VupJhieYfOrUItwBuXy06oJVXTDBFMivEFGeooJ",
	"oLEPJ9Ik48CfgBXaAvI4DtvWeAxD/3PlVevC90jjta7c6AXgLKgcPlWj0OjpdzsPr+7c2+hcfdPL+PT6",
	"6ZzxqKcIcLTj/CyuLFiitkIJPY4YdZQyMysFgkuiDEo3Jp0pwuzQkxiRAhtU4HMGbs8WCyeUHhjsxEIK",
	"okQMTPUs1CpNF6HbHJ1nX7W+/Xs6ULCFnVCtE2+HtnjbMutWY5oUMejMiHtUAfA0ThVEiOdRlcqLQKGW",
	"3vSTgO9tsC+UE8UnudT3YcC9Wgs8ST/cZIl+TlyhtFiJUTli2BPE9EjQnJk6m4EBkjjrTGU1/8XqYVIK",
	"U1Lm/dht3keFGzvrj1tXf6bnd+xVaU1W1UxSnLi3eUlxwrdbWLL0r3Jj4Pfc/6wHh5FYey/mUJbCLwNJ",
	"lv+XOWL7VzkU459ZBZ1B0eEVXYuKW000FUwxovBr/DiLL8NCQRa1p96l8fWo0XuBkqFXv6UuDCl0m3xh",
	"8QSjP+X9DVzCn5woz2RMzzMqo0gvQMC7SGLTW7mKnXz9Gk+U3kab9GnE7qmbsk6rEEG2rHKdy27jomfT",
	"EqPva99q7JfGpXek4sG8hJ7gJhZh65bOozXX8aNYrrO5u/6z66xDixTihnrPjUv/Jb03Jv0f6V3vn+KE",
	"1Hm0xijZK5sJ7bUSMZLGvEduY00ak1xnw3Vuus4daUz6L2kficN+6R1pXILov3GdRzBBm6BIdAZUZE8C",
	"QAu6f3u7ffN79LE0dmpsPO/9W4T/TsB/3/f+HR/z/i2OSfmxUxNj8I7Kze/ds7dbt++4zpPWszetrdtY",
	"K2y6ziNJ1hWp/ev1zqanNRCQZCS7hA9iTJc4XYGqe1rVl+aMTwxFZSnCJUNRXecl0dcIXcF/5jbWds86",
	"sEgzQnvDdVYFmjZ5A9LDQX5rIc9MgOWs2a2LuuYZDEmfK+EedJWbRo9SlTKAPeH8DpmMMkeRNp2+lNHD",
	"AhbR7FO4I2dUvfgPqDO3DVOuAD6af0WFYlilhNLtwD7A3k7zyFGS0EbVwTuX/tH+0Ym7UMuyqtFPnzo/",
	"vHKd1dbmL7vnr0r75v1u1pRbC/RLSX5hil/cxjOGgcwI1XR+vpoMtG7RrGo0Ve6n9KIvIRn8oblRn3Tt",
	"Z2nrg1wavUkTHqlngYoMlDSzvatUSi0ltKcOMwcDtheNa8jyGngQh7rSviPTJckvnoQ3bvR0f6rGd7xK",
	"xjHbl3WdkDlflqebsSNdNl829X6AMRZ5Hwcbl/vT0I7oM22j5jF+ibVAPqIOIG57K2IRh/gmrVbX2exs",
	"bO7e+wtRECZSDNn748h0KUdcJMaP8A/eY1q5GG7fa1jU567bXOXXvYyWjOaUwY5vX7piGio9A1416GW7",
	"q3KZ+vtJVacntMRITwgkwxmR9lUt+sb1WU0zZCWQGXYOA61HZmPNbdwPq4riE6woTRb86rFBcb15VZdh",
	"A9PYlL1XRSIZAbp4eQwy8y+1FqnPT/Unn3FZBSeP91hFLtLCkkYmAgzBAPS/1IX+OTAthoxcQxYe99b+",
	"cvg5H3P8IhWHoCCDmKQycPHmyDIXKaMwths1nUpmW6g+SHim+wWY3355yXU2A1ZTm7JZ6n8CflKqp/Ma",
	"D9zGK3pOVfrVxrnD7+8pECku26b8jBlRRYOjFvHMYeZArcvrneuvd9d/3teJNLTD5kbXNIKBuHjTj7wo",
	"GLO2ligtBcUOmmHEXgnztHGjl/gm6E1N9XcuTS0D3YKQ/HbRx47OoX4Eucncom3XrMlCoaLai/X5A2Wj",
	"WtAO2npdLxye+bhkQ4IU5jVjvlCVLRuYhemjhw4fLx1GB/q2t/xyoFaxbNw/NFjcueKBiQNFFNAEulxT",
	"c5O5gwfGDoxDLWQvQuYVyAoeFWBzDjL9QumNNTIYm4OjI755nMl9DOxDYU0NE1g1Q7eQoBTHxvw8fxxJ",
	"l2sorc+b45cWEiGxPu+RJnuQ3KJY34SRrJuucwc5GgtyXbP7hheqQUtBaPvVhfbtOxDwY3j87FeehavA",
	"qler3n4cwxshncOJl0S9khPedwH3CqcDk/FMQTMqRjI74V0MeEIuztHAR5v2QMDNTK4CG5gWM3c8fKUw",
	"I9uLhJd3IlE81KpcAYUaLIDFYTFtJlEuT4xRWtEcN2zpI6OuK0MtB2hmiXIQtG+jMt0PEYqvYDTcINcv",
	"gkAhEAvX4V63Eazj3EKzRbzyi/1ZhdMK2THgDJN7lM4BySz0awVa0a4EWZZsdw+GxI/8l4/Jp0qeFSKw",
	"0G1wyi7UNBm6W3EecAmQdqVPjL8naK25zpXWg0cwPH/Ldf7bI/QQSl6cOITgYVnzRS9sakoXNFqrAQFZ",
	"Cy5bphOuo8S5qICQ9EDisL0Chc5Jsx5uxUPFPqaAQFg5o2ZYyax3G2tkR6oY02cMK+S6Z8MDy/7QUFb6",
	"RpYPFAWVRI90ewhO2iOeg23WwZmY+Iz3E5egwX6y/Hj+ok+6J6iN0MgID8KbJjah8iicxm39zyAp0oAN",
	"ROQJ5kbDKw+N19CfpAoWusqNiB2028iya4W9OhiaJTW+I6UH4hNgsVWt2cvYjzhQPVh/n7k9HJ2Z+xzX",
	"85Y01bIlgb3haM1e9o3+Y97gqTeJmbnPIxtFsv2BAtXH4HJNt62ceqdaA5XPZqepZghr6sMtGByuESLh",
	"SQEpEKBWOXCqqvFlAdQqoiJwuFb5f1VtL7jvfTIlr1ipeQ9nGydz1yRHgNkRjOk8JvsDUflLFqgUYPFs",
	"2G+zBxswmbmfLixYwBZyQmA2oIi8WLNgGZgWEHn53+rAXAkuPYu9Th5si31Bpr4Kf4Rvnom+f0S2cMUU",
	"VFZ5kBY4LoRKkWyGpA33OiORjq2zsFcW09ymNKBsrJENKDl2N7HWBmF5sxrX7rHRTWnjyRQeTiPPETDC",
	"E+dAFy1SjRfKGpD1OrwzyRM4aBU+w0kAP4Ynx8nSdsiHIGJMJwEbhbXNwl6AGUZYa523t9KS5FNstbii",
	"+8C1dncJebYOT5jRSKh07hwEmH86PO3nOsiBlJFlXhnuMObDbFciQUqXmMyROJFqHWMcR2ThInRZOzJn",
	"TaL0wdRWbx/5kh+eqGlXb1DGomeQTCAqj5Py193GFde5I6mwPpxEGda5ghg/vEJHpUJKbUFE58Wjai3n",
	"dvvp/ZTaI2O8PpMOYaM8UvE0hHRajtZQhxZoltV5VhnqD0V2hkKXjVB9D5Z5VqdoIL8pzB5vEEn4j8jG",
	"wZ9GWu7X9Z74/6R94bXr3BJj+2cBrLfPeIT4CLM8pDyX335nNo49sf3yaUpjAvV2SsfBgQTF9tTI4DgV",
	"NBKOgmgFeDNsAY/RXcJUMIEFbFutApPtyOOKh1swWeEvMNt3rXVuFV3pSHTkVb0yG0IRWepJAIebGXHs",
	"A9S5LAlrulKXN1kRVmhtB7VY3/rSDtHxM/f7HaOPxMgHqzt8qtLFg8agURBWptrwZ8uOKmNhT87dIARy",
	"EDFkajf7t5C04WPAFpBRStZAGMdyNAi5IFVXoex3LOPpr/XnKZQXbIE2+OUMwbBX9PrzUVvO6895aznC",
	"Mw2X2OcwLSign3r3QQX8025BJf/ioYDmPwxvJu6FzkdTYS9rJo1GwlqJYi8sPfWa4hcy420P4RHTty/a",
	"N7zVhGotCOwWnyEA4lYjG9bobMQB9gh1AT6cDhpecE8Agt1a6AQAjR22/Mjm5gcNQ06kMf1HJP6P0KUE",
	"/wnDiX4nJhqJzmjc9403Q+WeE70qKFdwhAg38ndxOLN0NhMMdVrYr33xcuvyerC6fOXICfIOYvH33+o/",
	"rKh2b5Y/h0zBHjL8hjqJN0I63aZRMMLecwmbR9Bb4tI/2l9f9jy/R9+l3kvCXlt7tqUw8R4J+4yBfUou",
	"W34LwWQWw9OHnljsN1nbS/7SkR4V/tKw5/AXV29k3N+LVDkXMSn8MuMjGCyM5qIO1DaBRKJdyGHSe8iP",
	"nKN4xw0LOGHOHa6w+ZRABNAXsQFd3iL7hL2NwB8sjsoRjZG6pYWRjsf+fIkIdFCBaHXB10X4glB3j7IE",
	"pYRX9hDopr3VNGTbN65gMeiKChCPni5izWegeimUst/V0z+VejqN2tTyr44S4iISGvMG9o8bM1m4/JPK",
	"ZNxGZCHH42LBsk3cKYTs1cHxoG9KPElz01maJnvVI6o01AmroUBw7Mt6gkAkhqz6KRBDsQNwlcEIBadC",
	"JyMWmWJq64KiWrhybaJodL66h9q+CUnHlD/ynmpuAsURUd4BxmL8CrvHJq9k3KVPiF1Bhdo95BaB4aj4",
	"7xhjBrcssuEHdfMNWl4Jh4zCJiKDP+Dve8rYcQAUa5ZojiQE4iMT4MIwIh9gDf/xbJq3PyyleftQqrdL",
	"n/z7YG2eUCgoUs2WseFeZl14x8yYcHV1rbbCvGnISlm2bF7mdvv6m/Y3d7dfPg26zQVA0izDD0lYaZfk",
	"B4riDer31xye42CuPIkRbujLb7LmICRhCrBlVSucruEmc+yqfl0ORA8afwoCDfvaZdmdya54wydvkd5k",
	"iWkIoopt5DMRsmtC1IOYnSpG9nGLRS6ZsbtAItGF8QGF76id6MR9OGEc+tc9j7X3jmRkmIO6kOgRlYpF",
	"dSNZ6bcHPXmI6KrRU+XifD9talSrahhN6rdnSWRh/5AbFsJTSl5KqNEXJ9+A1qNMZKHggQfJd6K5GrWW",
	"Jh/1Yb8zTsE+zk9MZsxOE/hN21knIq2vN2DT8s3uJj5C9/9LPgCRuIsApOFmQeIEIoxAhGEfgdA6nAkt",
	"JEzxIS2ITHSb4yxC1rRHYxHSsaeyn1iGBU1dBpFuCosaL7PrB3iv9IZ0ZLokxUWOe7MiFJRpdRkE5sUR",
	"zdoL+yRridS0ghZt+0k9fxOj4bDHfjmzSC901aItInXHinM0kgnqp4jYHSvaQyd3sONeoVor2oy2ADw6",
	"DLeUUDHOJCaFmiavaCry4rPIS/MmbIL2ILh21oMEzWBchliD8Ys890CsUdFQYhPLJo2aJiqG08ZJaVq2",
	"gV5e6aMK07TRVmIcqoyAUJHY7/NWmW0d+NKSOtc39vdB2dUmBGSrWpvolzjVJoZVliYSRIlChOGWHhrC",
	"qQXkJJivCkjIF2D+WJ9E5AsP4lDKiE8LnpDQ6DDcUkLFOElMwtpsRANnvluHKjj15tPhkmpE38qsnl20",
	"damguHiW2Ixhqeh0ZKQ8QiHyj0INsEy+IENeebufD62nrY8ir1k3wCGUV/7GyabfEMtWli2TIVvcjdMH",
	"19uuSZGuzHvn0IoXc8/lkHCIBSzTbnsa/U9id7Ds5xj+3pHtEDf4WLR48WiegqQ6/KCzr7AEQI2dQRwF",
	"4FMlWiMy6Y5AFz8/8eDtPU+5qI8Ul0WYQOc++pV5mrzlNsRr4s95Yw3L7dDjclX80vrhU2WtrgTl0ufk",
	"yuALWAag6BfZ6aQfdqkMkY6ducH/8rqQbqHmvonXRH0xG9TloJAxb7V6ZYAFWzpGq92oh3HsmqgvFFgT",
	"FU7b3tJLMCB8QRG4IOqJClrMvZRG56uDBOxGYcXG7oeGa7XOXKqta6veNB9cbH/7gr3T958Dw7Tq2QIw",
	"StcCMTsRL5NXZ8EEmmyD5BZHKL3NdTYCouzeuL979rvt19+4zh9TLuFZBLQPYiRaxzpbZwThSY9CGEtw",
	"MsKqgz5qYy0yarIy6Z8sDEilIAT7p1WEuDFa/Q6Z7I94K6QKWqxX53VZRdF7lhX5EzzRXoWO0BPX2Wyd",
	"W+1cv9O+cE2k2u1cCEJM14tAG3YLIDKHYAIkD0KqdHMiuftkN43St6EMmZKmEaUw3JFij0BrSh63Tgf/",
	"z7uCEYeZ6PkHIOZCAJnUM/m9gAOuVuUKKHxZAxX6iSdzJiPFdR53l4FpqQg3xuH3NZSSjvpZCgdzPvfH",
	"HWAMBIOgZobysR72fCsK9rGACOacz0dVAYZVqNc0Q1Z46hQrruZTv60eJIPb/JPbPA+bl667jXuBvCdG",
	"U+CRivUZAsszhqp1zVZrsmkXFgyz+o4i27I4RdH4wfFNaA0J+lTZJj3sizzLrEgBgqyLyk/kdI9faosO",
	"RcAlQyJDnsX1fJYnWBmEj/KwKwUK9jRuMotyMWafpMj7zy2R64RTxkkd6pSUYXSjbAP7HXRI4e3p+a4s",
	"ynz0QD/fdQCL/z71TlW2TcNakhmpUHxi/pOIEksxFJQ6EhKm2dC6vN65/trzMNd/hlcX08vZFIYxKO3Q",
	"HyMEAwrQpfCFTY0hvxIXxTuViCwZisqxQ0IRfAwdkWduY03yvpFc5+XuWWd7616i1UEw+RMPWn8EZQBl",
	"B4CObJdpVV+aMzxce64fJ0q+EdJFzJmkkjuBOy0BxAzXV2KS19O9lR7UVNJdFJFJjoxocG6YhBLhfQzM",
	"ZUz+uqnlJnOLtl2bLBQ0oyxri4ZlT77//vvvF+SaCuntD3I6p8tVkJvM+SnhqKoC/s3QF9QK+YtiGrVp",
	"oxJ5y+/ATvyi1uxl8u+gEXDsN1WvRH/EzSmJ31DBg/CH8Go/+SO+Hx75DeVrED/BWZN/h0EB4lfsX5I/",
	"IVqfOXHm/wcAAP//Mk0yaqgsAQA=",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
